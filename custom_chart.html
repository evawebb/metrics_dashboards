<!DOCTYPE html>
<html>
  <head>
    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
      Rally.onReady(function () {
        Ext.define('ZzacksApp', {
          extend: 'Rally.app.TimeboxScopedApp',
          scopeType: 'release',
          data_keys: [
            'FormattedID',
            '_type',
            'Name',
            'PlanEstimate',
            'Resolution',
            'Tags',
            'RevisionHistory',
            'Revisions'
          ],
          columns: {
            'FormattedID':     { key: 'FormattedID',    center: true },
            'Type':            { key: '_type',          center: true },
            'Name':            { key: 'Name',           center: false },
            'Estimate':        { key: 'PlanEstimate',   center: true },
            'Created':         { key: 'CreatedDate',    center: true, date: true },
            'Defined':         { key: 'DefinedDate',    center: true, date: true },
            'Started':         { key: 'StartedDate',    center: true, date: true },
            'Completed':       { key: 'CompletedDate',  center: true, date: true },
            'Accepted':        { key: 'AcceptedDate',   center: true, date: true },
            'Released':        { key: 'ReleasedDate',   center: true, date: true },
            'Backtracks':      { key: 'BackCount',      center: true },
            'Lead Time':       { key: 'LeadTime',       center: true },
            'Lead Time Ceil':  { key: 'LeadTimeCeil',   center: true },
            'Lead Time Round': { key: 'LeadTimeRound',  center: true },
            'Resolution':      { key: 'Resolution',     center: false }
          },

          launch: function() {
            this._mask = new Ext.LoadMask(Ext.getBody(), {
              msg: 'Please wait...'
            });
            this._mask.show();
            this.fetch_iterations(this.getContext().getTimeboxScope());
          },

          onTimeboxScopeChange: function(ts) {
            this._mask.show();
            this.fetch_iterations(ts);
          },

          // Create a list of filters, one for each iteration in the selected
          // quarter.
          fetch_iterations: function(ts) {
            this.total_lead_ms = 0;
            this.count_lead_times = 0;
            this.avg_lead_time = '';
            this.release_dates = [];
            this.avg_cycle_time = '';
            this.num_iterations = 0;
            this.total_throughput = 0;
            this.avg_throughput = 0;

            var start = ts.record.raw.ReleaseStartDate;
            var end = ts.record.raw.ReleaseDate;
            var start_filter = Ext.create('Rally.data.wsapi.Filter', {
              property: 'StartDate',
              operator: '>=',
              value: start
            });
            var end_filter = Ext.create('Rally.data.wsapi.Filter', {
              property: 'StartDate',
              operator: '<',
              value: end
            });

            var store = Ext.create('Rally.data.wsapi.Store', {
              model: 'Iteration',
              fetch: ['Name', 'StartDate']
            }, this);
            store.addFilter([start_filter, end_filter], false);
            store.load({
              scope: this,
              callback: function(records, operation) {
                if (operation.wasSuccessful()) {
                  this.num_iterations = records.filter(function(r) {
                    return r.get('StartDate').getTime() < Date.now();
                  }).length;

                  var filters = records.map(function(r) {
                    return Ext.create('Rally.data.wsapi.Filter', {
                      property: 'Iteration.Name',
                      value: r.get('Name')
                    });
                  });

                  this.fetch_stories(filters, []);
                }
              }
            });
          },

          // Recursively fetch stories for each iteration filter and add them
          // all together.
          fetch_stories: function(filters, stories) {
            var store = Ext.create('Rally.data.wsapi.artifact.Store', {
              models: ['UserStory', 'Defect'],
              fetch: this.data_keys
            }, this);
            store.addFilter(filters[0])
            store.load({
              scope: this,
              callback: function(records, operation) {
                filters.shift();
                if (filters.length > 0) {
                  this.fetch_stories(filters,
                    operation.wasSuccessful() ?
                      stories.concat(records) :
                      stories
                  );
                } else {
                  this.fetch_revisions(stories, 0);
                }
              }
            });
          },

          // Recursively fetch the revisions for each story.
          fetch_revisions: function(stories, index) {
            var story = stories[index];
            var rh_split = story.get('RevisionHistory')._ref.split('/');
            var rh_oid = parseInt(rh_split[rh_split.length - 1]);
            var store = Ext.create('Rally.data.wsapi.Store', {
              model: 'Revision',
              sorters: [{
                property: 'RevisionNumber',
                direction: 'ASC'
              }]
            }, this);
            var rh_filter = Ext.create('Rally.data.wsapi.Filter', {
              property: 'RevisionHistory.ObjectID',
              value: rh_oid
            });
            store.addFilter(rh_filter);
            store.load({
              scope: this,
              callback: function(records, operation) {
                if (operation.wasSuccessful()) {
                  story.data.Revisions = records.map(function(r) {
                    return r.data;
                  });
                }

                if (index < stories.length - 1) {
                  this.fetch_revisions(stories, index + 1);
                } else {
                  this.get_story_data(stories, []);
                }
              }
            });
          },

          // Given a millisecond count, format it as 'X days, Y hours'.
          format_ms: function(ms, method = null) {
            var hours = Math.round(ms / 1000 / 60 / 60);
            var days = Math.floor(hours / 24);
            hours -= (days * 24);

            if (method == 'ceil') {
              days += (hours > 0) ? 1 : 0;
            } else if (method == 'round') {
              days += (hours >= 12) ? 1 : 0;
            }

            var out = '';

            if (days > 0) {
              out += days;
              if (days == 1) {
                out += ' day';
              } else {
                out += ' days';
              }

              if (!method) {
                out += ', ';
              }
            }

            if (!method) {
              out += hours;
              if (hours == 1) {
                out += ' hour';
              } else {
                out += ' hours';
              }
            }

            return out;
          },

          // Recursively reformat the data for each story. Once they're all
          // reformatted, pass the data along to the table building function.
          get_story_data: function(raw_stories, stories) {
            var raw_story = raw_stories[0];
            var story = {};
            this.data_keys.forEach(function(k) {
              story[k] = raw_story.get(k);
            });

            // Make the tags readable.
            story.Tags = story.Tags._tagsNameArray.map(function(o) {
              return o.Name;
            });

            // Make the type more readable and color the row based on the type.
            if (story._type == 'hierarchicalrequirement') {
              story._type = 'S';
              story.color = '#ffffff';
            } else if (story._type == 'defect') {
              if (story.Tags.indexOf('Customer Voice') == -1) {
                story._type = 'D';
                story.color = '#ffa500';
              } else {
                story._type = 'C';
                story.color = '#ff83fa';
              }
            }

            // Calculate the transition dates.
            var dates = [null, null, null, null, null, null];
            var indices = [null, 'Defined', 'In-Progress', 'Completed', 'Accepted', 'Released'];
            var back_count = 0;
            var back_flag = false;
            story.Revisions.forEach(function(r) {
              var ms = r.Description
                .match(/SCHEDULE STATE changed from \[(.*?)\] to \[(.*?)\]/);

              if (r.Description == 'Original revision') {
                dates[0] = r.CreationDate;
              } else if (ms && indices.indexOf(ms[2]) >= 0) {
                if (ms && indices.indexOf(ms[2]) >= 0) {
                  var i = indices.indexOf(ms[2]);
                  dates[i] = r.CreationDate;
                  for (var j = i + 1; j < indices.length; j += 1) {
                    if (!back_flag && dates[j]) {
                      back_count += 1;
                      back_flag = true;
                    }
                    dates[j] = null;
                  }
                  back_flag = false;
                }
              }
            });
            if (dates[0]) {
              story.CreatedDate = dates[0];
            }
            if (dates[1]) {
              story.DefinedDate = dates[1];
            }
            if (dates[2]) {
              story.StartedDate = dates[2];
            }
            if (dates[3]) {
              story.CompletedDate = dates[3];
            }
            if (dates[4]) {
              story.AcceptedDate = dates[4];
            }
            if (dates[5]) {
              story.ReleasedDate = dates[5];
            }
            story.BackCount = back_count;

            // Calculate lead time.
            if (story.StartedDate && story.ReleasedDate) {
              var lead_ms = story.ReleasedDate - story.StartedDate;
              this.total_lead_ms += lead_ms;
              this.count_lead_times += 1;
              story.LeadTime = this.format_ms(lead_ms);
              story.LeadTimeCeil = this.format_ms(lead_ms, 'ceil');
              story.LeadTimeRound = this.format_ms(lead_ms, 'round');
            }

            // Record the release date so that cycle time can be calculated.
            if (story.ReleasedDate) {
              this.release_dates.push(story.ReleasedDate);
            }

            // Process the next story.
            stories.push(story);
            raw_stories.shift();
            if (raw_stories.length > 0) {
              this.get_story_data(raw_stories, stories);
            } else {
              this.calculate_statistics(stories);
            }
          },

          // Calculate the overall statistics for the entire table.
          calculate_statistics: function(stories) {
            // Average lead time.
            var lead_ms = this.total_lead_ms / this.count_lead_times;
            this.avg_lead_time = this.format_ms(lead_ms);

            // Average cycle time.
            var first_release = this.release_dates[0].getTime();
            var last_release = this.release_dates[0].getTime();
            for (var i = 1; i < this.release_dates.length; i += 1) {
              var this_release = this.release_dates[i].getTime();
              if (this_release < first_release) {
                first_release = this_release;
              }
              if (this_release > last_release) {
                last_release = this_release;
              }
            }
            this.avg_cycle_time = this.format_ms((last_release - first_release) / (this.release_dates.length - 1));

            // Throughput.
            this.total_throughput = this.release_dates.length;
            this.avg_throughput = Math.round(this.total_throughput / this.num_iterations * 100) / 100;

            this.build_html(stories);
          },

          // Construct the HTML table to display the story data.
          build_html: function(stories) {
            // The table.
            var table = '<table><thead><tr><th>' +
              Object.keys(this.columns).join('</th><th>') +
              '</th></tr></thead>';
            var that = this;
            stories.forEach(function(story) {
              table += that.build_table_row(story);
            });
            table += '</table>';

            // The table-wide statistics.
            var stats = '<div>';
            stats += '<strong>Average lead time:</strong> ' + this.avg_lead_time + '<br />';
            stats += '<strong>Average cycle time:</strong> ' + this.avg_cycle_time + '<br />';
            stats += '<strong>Throughput:</strong> ' + this.total_throughput + ' stories/quarter, ' + this.avg_throughput + ' stories/iteration<br />';
            stats += '<br /></div>';

            this.removeAll();
            this.add({
              xtype: 'component',
              html: stats + table
            });
            this._mask.hide();
          },

          // Given a story object, build an HTML row showing the relevant data.
          build_table_row: function(story) {
            var data = story;
            var row = '<tr>';
            var that = this;

            Object.keys(this.columns).forEach(function(col) {
              var datum = data[that.columns[col].key];
              var center = that.columns[col].center;
              if (!datum) {
                datum = '';
              } else if (that.columns[col].date) {
                datum = datum.toDateString();
              }

              row += ('<td ' +
                (center ? 'class = "center" ' : '') +
                ('bgcolor="' + data.color + '" ') +
                '>' +
                datum +
                '</td>'
              );
            });

            return row;
          }
        });

        Rally.launchApp('ZzacksApp');
      });
    </script>

    <style type="text/css">
      table {
        border-collapse: collapse;
      }

      td, th {
        border: 1px solid black;
      }

      .center {
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div>You shouldn't be able to see this! (*ﾉωﾉ)</div>
  </body>
</html>
