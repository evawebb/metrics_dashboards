<!DOCTYPE html>
<html>
  <head>
    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
      Rally.onReady(function () {
        Ext.define('ZzacksApp', {
          extend: 'Rally.app.TimeboxScopedApp',
          scopeType: 'release',
          data_keys: [
            'FormattedID',
            '_type',
            'Name',
            'PlanEstimate',
            'Resolution',
            'Tags',
            'RevisionHistory',
            'Revisions'
          ],
          columns: {
            'FormattedID':     { key: 'FormattedID',    center: true },
            'Type':            { key: '_type',          center: true },
            'Name':            { key: 'Name',           center: false },
            'Estimate':        { key: 'PlanEstimate',   center: true },
            'Created':         { key: 'CreatedDate',    center: true, date: true },
            'Defined':         { key: 'DefinedDate',    center: true, date: true },
            'Started':         { key: 'StartedDate',    center: true, date: true },
            'Completed':       { key: 'CompletedDate',  center: true, date: true },
            'Accepted':        { key: 'AcceptedDate',   center: true, date: true },
            'Released':        { key: 'ReleasedDate',   center: true, date: true },
            'Backtracks':      { key: 'BackCount',      center: true },
            'Skipped':         { key: 'Skipped',        center: true },
            'Lead Time':       { key: 'LeadTime',       center: true },
            'Lead Time Ceil':  { key: 'LeadTimeCeil',   center: true },
            'Lead Time Round': { key: 'LeadTimeRound',  center: true },
            'Resolution':      { key: 'Resolution',     center: false }
          },
          months: [
            'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
            'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
          ],
          complete_dates: true,

          launch: function() {
            this._mask = new Ext.LoadMask(Ext.getBody(), {
              msg: 'Please wait...'
            });
            this._mask.show();
            this.project_oid = this.getContext().getProject().ObjectID;
            this.fetch_iterations(this.getContext().getTimeboxScope());
          },

          onTimeboxScopeChange: function(ts) {
            this._mask.show();
            this.fetch_iterations(ts);
          },

          // Create a list of filters, one for each iteration in the selected
          // quarter.
          fetch_iterations: function(ts) {
            this._mask.msg = 'Fetching iterations...';
            this._mask.show();

            this.total_stats = {
              C: { name: 'CV Defects' },
              D: { name: 'Defects' },
              S: { name: 'Stories' }
            };

            this.start_date = ts.record.raw.ReleaseStartDate;
            this.end_date = ts.record.raw.ReleaseDate;
            var start_filter = Ext.create('Rally.data.wsapi.Filter', {
              property: 'StartDate',
              operator: '>=',
              value: this.start_date
            });
            var end_filter = Ext.create('Rally.data.wsapi.Filter', {
              property: 'StartDate',
              operator: '<',
              value: this.end_date
            });

            var store = Ext.create('Rally.data.wsapi.Store', {
              model: 'Iteration',
              fetch: ['Name', 'StartDate']
            }, this);
            store.addFilter([start_filter, end_filter], false);
            store.load({
              scope: this,
              callback: function(records, operation) {
                if (operation.wasSuccessful()) {
                  this.num_iterations = records.filter(function(r) {
                    return r.get('StartDate').getTime() < Date.now();
                  }).length;

                  var filters = records.map(function(r) {
                    return Ext.create('Rally.data.wsapi.Filter', {
                      property: 'Iteration.Name',
                      value: r.get('Name')
                    });
                  });

                  this.fetch_stories(filters, []);
                }
              }
            });
          },

          // Recursively fetch stories for each iteration filter and add them
          // all together.
          fetch_stories: function(filters, stories) {
            this._mask.msg = 'Fetching stories...';
            this._mask.show();

            var store = Ext.create('Rally.data.wsapi.artifact.Store', {
              models: ['UserStory', 'Defect'],
              fetch: this.data_keys
            }, this);
            store.addFilter(filters[0]);
            store.load({
              scope: this,
              callback: function(records, operation) {
                filters.shift();
                if (filters.length > 0) {
                  this.fetch_stories(filters,
                    operation.wasSuccessful() ?
                      stories.concat(records) :
                      stories
                  );
                } else {
                  this.fetch_revisions(stories, 0);
                }
              }
            });
          },

          // Recursively fetch the revisions for each story.
          fetch_revisions: function(stories, index) {
            this._mask.msg = 'Fetching story histories... (' + (index + 1);
            this._mask.msg += ' of ' + stories.length + ')';
            this._mask.show();

            var story = stories[index];
            var that = this;
            var store = Ext.create('Rally.data.lookback.SnapshotStore', {
              fetch: ['ScheduleState', '_PreviousValues.ScheduleState', 'Project', '_PreviousValues.Project', '_ValidFrom', '_ValidTo'],
              hydrate: ['ScheduleState', '_PreviousValues.ScheduleState'],
              filters: [
                {
                  property: 'ObjectID',
                  operator: '=',
                  value: story.get('ObjectID')
                }
              ],
              listeners: {
                load: function(store, data, success) {
                  if (success) {
                    story.data.Revisions = data.filter(function(d) {
                      return (d.get('_PreviousValues.ScheduleState') === null 
                        || d.get('_PreviousValues.ScheduleState').length > 0)
                        && d.get('Project') == that.project_oid;
                    }).map(function(d) {
                      return {
                        from: d.get('_PreviousValues.ScheduleState'),
                        to: d.get('ScheduleState'),
                        on: d.get('_ValidFrom')
                      };
                    });
                  }

                  if (index < stories.length - 1) {
                    that.fetch_revisions(stories, index + 1);
                  } else {
                    that.get_story_data(stories, []);
                  }
                }
              }
            });
            store.load({
              scope: this
            });
          },

          // Given a millisecond count, format it as 'X days, Y hours'.
          format_ms: function(ms, method = null) {
            var hours = Math.round(ms / 1000 / 60 / 60);
            var days = Math.floor(hours / 24);
            hours -= (days * 24);

            if (method == 'ceil') {
              days += (hours > 0) ? 1 : 0;
            } else if (method == 'round') {
              days += (hours >= 12) ? 1 : 0;
            }

            var out = '';

            if (days > 0) {
              out += days;
              if (days == 1) {
                out += ' day';
              } else {
                out += ' days';
              }

              if (!method) {
                out += ', ';
              }
            }

            if (!method) {
              out += hours;
              if (hours == 1) {
                out += ' hour';
              } else {
                out += ' hours';
              }
            }

            return out;
          },

          // Recursively reformat the data for each story. Once they're all
          // reformatted, pass the data along to the table building function.
          get_story_data: function(raw_stories, stories) {
            this._mask.msg = 'Calculating story statistics...';
            this._mask.show();

            var raw_story = raw_stories[0];
            var story = {};
            this.data_keys.forEach(function(k) {
              story[k] = raw_story.get(k);
            });

            // Make the tags readable.
            story.Tags = story.Tags._tagsNameArray.map(function(o) {
              return o.Name;
            });

            // Make the type more readable and color the row based on the type.
            if (story._type == 'hierarchicalrequirement') {
              story._type = 'S';
              story.color = '#ffffff';
            } else if (story._type == 'defect') {
              if (story.Tags.indexOf('Customer Voice') == -1) {
                story._type = 'D';
                story.color = '#ffa500';
              } else {
                story._type = 'C';
                story.color = '#ff83fa';
              }
            }

            // Calculate the transition dates.
            var dates = [null, null, null, null, null, null];
            var indices = ['Idea', 'Defined', 'In-Progress', 'Completed', 'Accepted', 'Released'];
            var back_count = 0;
            var back_flag = false;
            story.Revisions.forEach(function(r) {
              var i = indices.indexOf(r.to);
              dates[i] = new Date(r.on);
              for (var j = i + 1; j < indices.length; j += 1) {
                if (!back_flag && dates[j]) {
                  back_count += 1;
                  back_flag = true;
                }
                dates[j] = null;
              }
              back_flag = false;
            });

            // Fill in missing dates.
            var filled = [false, false, false, false, false, false];
            if (this.complete_dates && (dates[0] || dates[1]) && dates[5]) {
              for (var i = 4; i >= 3; i -= 1) {
                if (!dates[i]) {
                  dates[i] = dates[i + 1];
                  filled[i] = true;
                }
              }

              if (dates[0]) {
                for (var i = 1; i <= 2; i += 1) {
                  if (!dates[i]) {
                    dates[i] = dates[i - 1];
                    filled[i] = true;
                  }
                }
              } else {
                if (!dates[2]) {
                  dates[2] = dates[1];
                  filled[2] = true;
                }
              }
            }

            // Assign the transition dates to the story.
            if (dates[0]) {
              story.CreatedDate = dates[0];
              story.CreatedDateFilled = filled[0];
            }
            if (dates[1]) {
              story.DefinedDate = dates[1];
              story.DefinedDateFilled = filled[1];
            }
            if (dates[2]) {
              story.StartedDate = dates[2];
              story.StartedDateFilled = filled[2];
            }
            if (dates[3]) {
              story.CompletedDate = dates[3];
              story.CompletedDateFilled = filled[3];
            }
            if (dates[4]) {
              story.AcceptedDate = dates[4];
              story.AcceptedDateFilled = filled[4];
            }
            if (dates[5]) {
              story.ReleasedDate = dates[5];
              story.ReleasedDateFilled = filled[5];
            }
            story.BackCount = back_count;

            // Check if this story skipped.
            var stage = 0;
            for (var i = 0; i < dates.length; i += 1) {
              if (stage == 0 && !dates[i]) {
                stage = 1;
              } else if (stage == 1 && dates[i]) {
                stage = 2;
              }
            }
            if (stage == 2) {
              story.Skipped = 'Y';
            }

            // Calculate lead time.
            if (story.StartedDate && story.ReleasedDate) {
              story.LeadTimeMs = story.ReleasedDate - story.StartedDate;
              for (var d = new Date(story.StartedDate); d <= story.ReleasedDate;
                   d.setDate(d.getDate() + 1)) {
                if (d.getDay() == 0 || d.getDay() == 6) {
                  story.LeadTimeMs -= 24 * 60 * 60 * 1000;
                }
              }

              story.LeadTime = this.format_ms(story.LeadTimeMs);
              story.LeadTimeCeil = this.format_ms(story.LeadTimeMs, 'ceil');
              story.LeadTimeRound = this.format_ms(story.LeadTimeMs, 'round');
            }

            // Process the next story.
            stories.push(story);
            raw_stories.shift();
            if (raw_stories.length > 0) {
              this.get_story_data(raw_stories, stories);
            } else {
              this.calculate_statistics(stories);
            }
          },

          // Calculate the overall statistics for the entire table.
          calculate_statistics: function(stories) {
            this._mask.msg = 'Calculating overall statistics...';
            this._mask.show();
            var that = this;

            // Filter out CV Defects that were not resolved.
            var filt_stories = stories.filter(function(s) {
              return !(s._type == 'C' && !s.Resolution.match(/[cC]hange$/));
            });

            // Throughput.
            Object.keys(this.total_stats).forEach(function(t) {
              that.total_stats[t].throughput_r = filt_stories.filter(function(s) {
                return (s._type == t && s.ReleasedDate);
              }).length;
              that.total_stats[t].throughput_a = filt_stories.filter(function(s) {
                return (s._type == t && (s.AcceptedDate || s.ReleasedDate));
              }).length;
            });

            // Weekly released.
            var weekdays = 0;
            var now = new Date();
            if (new Date(this.end_date) < now) {
              now = new Date(this.end_date);
            }
            for (var d = new Date(this.start_date); d <= now; d.setDate(d.getDate() + 1)) {
              if (d.getDay() != 0 && d.getDay() != 6) {
                weekdays += 1;
              }
            }
            Object.keys(this.total_stats).forEach(function(t) {
              that.total_stats[t].weekly_r = that.total_stats[t].throughput_r / (weekdays / 5.0);
            });

            // Average cycle time.
            Object.keys(this.total_stats).forEach(function(t) {
              that.total_stats[t].cycle_time = 0;
              that.total_stats[t].cycle_count = 0;
            });
            filt_stories.forEach(function(s) {
              if (s.StartedDate && s.ReleasedDate) {
                that.total_stats[s._type].cycle_time += 
                  (s.ReleasedDate - s.StartedDate);
                that.total_stats[s._type].cycle_count += 1;
              }
            });
            Object.keys(this.total_stats).forEach(function(t) {
              if (that.total_stats[t].cycle_count > 0) {
                that.total_stats[t].cycle_time /= that.total_stats[t].cycle_count;
              }
            });

            this.build_html(stories);
            this.build_plot(stories);
            this.build_flow_dia(stories);
            this._mask.hide();
          },

          // Construct the HTML table to display the story data.
          build_html: function(stories) {
            var that = this;

            // The table.
            var table = '<table><thead><tr><th>' +
              Object.keys(this.columns).join('</th><th>') +
              '</th></tr></thead>';
            stories.forEach(function(story) {
              table += that.build_table_row(story);
            });
            table += '</table>';

            // The table-wide statistics.
            var stats = '<table><thead><tr><th>Type</th>' +
              '<th title="Number of stories or defects accepted in this quarter.">Accepted Throughput</th>' +
              '<th title="Number of stories or defects released in this quarter.">Released Throughput</th>' +
              '<th title="Average number of stories or defects released each week this quarter.">Weekly Released Avg.</th>' +
              '<th title="Average cycle time (from Started to Released) for stories or defects this quarter.">Release Cycle Time Avg.</th>' +
              '</tr></thead>';
            Object.keys(this.total_stats).forEach(function(t) {
              var ts = that.total_stats[t];
              var label = 'defects';
              if (t == 'S') {
                label = 'stories';
              }
              stats += '<tr><td class="center">' + ts.name + '</td>';
              stats += '<td class="center">' + ts.throughput_a.toLocaleString() + ' ' + label + '</td>';
              stats += '<td class="center">' + ts.throughput_r.toLocaleString() + ' ' + label + '</td>';
              stats += '<td class="center">' + ts.weekly_r.toLocaleString() + ' ' + label + '</td>';
              stats += '<td class="center">' + that.format_ms(ts.cycle_time) + '</td>';
              stats += '</tr>';
            });
            stats += '</table>';

            this.removeAll();
            this.add({
              xtype: 'component',
              html: stats + '<br />' + table
            });
          },

          // Given a story object, build an HTML row showing the relevant data.
          build_table_row: function(story) {
            var data = story;
            var row = '<tr>';
            var that = this;

            Object.keys(this.columns).forEach(function(col) {
              var datum = data[that.columns[col].key];
              var center = that.columns[col].center;
              var filled = false;
              if (!datum) {
                datum = '';
              } else if (that.columns[col].date) {
                filled = data[that.columns[col].key + 'Filled'];
                datum = datum.toDateString();
              }

              row += ('<td class="' +
                (center ? 'center ' : '') +
                (filled ? 'filled ' : '') +
                '" ' +
                ('bgcolor="' + data.color + '" ') +
                '>' +
                datum +
                '</td>'
              );
            });

            return row;
          },

          // Make a scatter plot.
          build_plot: function(stories) {
            var that = this;
            var data = {
              series: [
                {
                  name: 'Stories',
                  data: []
                },
                {
                  name: 'Defects',
                  data: []
                },
                {
                  name: 'CV Defects',
                  data: []
                }
              ]
            };
            var indices = ['S', 'D', 'C'];
            stories.forEach(function(s) {
              data.series[indices.indexOf(s._type)].data.push(s);
            });
            data.series.forEach(function(c) {
              c.data = c.data.map(function(s) {
                if (s.LeadTimeMs && s.ReleasedDate) {
                  var d = s.LeadTimeMs / 1000 / 60 / 60 / 24;
                  var n = s.Name;
                  if (n.length > 40) {
                    n = n.substring(0, 37) + '...';
                  }
                  return { 
                    x: s.ReleasedDate, 
                    y: d, 
                    z: s.PlanEstimate || 0,
                    name: n, 
                    fid: s.FormattedID,
                    year: s.ReleasedDate.getFullYear(),
                    month: that.months[s.ReleasedDate.getMonth()],
                    day: s.ReleasedDate.getDate()
                  };
                } else {
                  return null;
                }
              }).filter(function(p) { return p });
            });

            var chart = this.add({
              xtype: 'rallychart',
              loadMask: false,
              chartData: data,
              chartConfig: {
                chart: {
                  type: 'bubble',
                  zoomType: 'xy'
                },
                title: { text: 'Lead Time This Quarter' },
                xAxis: { 
                  title: { text: 'Release date' },
                  //tickInterval: 2 * 24 * 60 * 60 * 1000,
                  labels: { 
                    formatter: function() {
                      return new Date(this.value).toDateString();
                    },
                  }
                },
                yAxis: { 
                  title: { text: 'Lead time (days)' },
                  min: 0
                },
                tooltip: {
                  pointFormat: 
                    '<b>{point.fid}</b>: {point.name}<br />' +
                    'Released on {point.day} {point.month} {point.year}<br />' +
                    'Lead time: {point.y:.2f} days<br />' +
                    'Estimated at {point.z} points'
                },
                plotOptions: {
                  bubble: {
                    sizeBy: 'width'
                  }
                }
              }
            });
          },

          // Build a cumulative flow diagram.
          build_flow_dia: function(stories) {
            var labels = [
              // 'CreatedDate',
              // 'DefinedDate',
              'StartedDate',
              'CompletedDate',
              'AcceptedDate',
              'ReleasedDate'
            ];

            var totals = {};
            var start = {};
            var now = new Date();
            if (new Date(this.end_date) < now) {
              now = new Date(this.end_date);
            }
            for (var d = new Date(this.start_date); d <= now; d.setDate(d.getDate() + 1)) {
              totals[d.toDateString()] = {};
            }
            labels.forEach(function(dt) {
              Object.keys(totals).forEach(function(date) {
                totals[date][dt] = 0;
              });
              start[dt] = 0;
            });

            stories.forEach(function(s) {
              prev_state = null;

              labels.forEach(function(dt) {
                if (s[dt]) {
                  if (totals.hasOwnProperty(s[dt].toDateString())) {
                    totals[s[dt].toDateString()][dt] += 1;
                    if (prev_state) {
                      totals[s[dt].toDateString()][prev_state] -= 1;
                    }
                  } else {
                    start[dt] += 1;
                    if (prev_state) {
                      start[prev_state] -= 1;
                    }
                  }

                  prev_state = dt;
                }
              });
            });

            var prev = start;
            var categories = [];
            var mapped_series = {};
            labels.forEach(function(dt) {
              mapped_series[dt] = [];
            });
            for (var d = new Date(this.start_date); d <= now; d.setDate(d.getDate() + 1)) {
              var df = d.toDateString();
              categories.push(df);
              labels.forEach(function(dt) {
                totals[df][dt] += prev[dt];
                mapped_series[dt].push(totals[df][dt]);
              });
              prev = totals[df];
            }

            var series = [];
            labels.forEach(function(dt) {
              series.push({
                name: dt.slice(0, -4),
                data: mapped_series[dt]
              });
            });

            var chart = this.add({
              xtype: 'rallychart',
              loadMask: false,
              chartData: { series: series, categories: categories },
              chartConfig: {
                chart: {
                  type: 'area'
                },
                title: { text: 'Release Cumulative Flow' },
                xAxis: { 
                  title: { enabled: false },
                  tickInterval: 7
                },
                yAxis: { title: { enabled: false } },
                plotOptions: {
                  area: {
                    stacking: 'normal',
                    lineColor: '#666666',
                    lineWidth: 1,
                    tooltip: { split: true, valueSuffix: ' stories' },
                    marker: { enabled: false }
                  }
                }
              }
            });
          }
        });

        Rally.launchApp('ZzacksApp');
      });
    </script>

    <style type="text/css">
      table {
        border-collapse: collapse;
      }

      td, th {
        border: 1px solid black;
      }

      .center {
        text-align: center;
      }

      .filled {
        font-style: italic;
        color: #808080;
      }
    </style>
  </head>
  <body>
    <div>Ã¸</div>
  </body>
</html>
