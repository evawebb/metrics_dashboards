<!DOCTYPE html>
<html>
  <head>
    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
      Rally.onReady(function () {
        Ext.define('ZzacksApp', {
          extend: 'Rally.app.TimeboxScopedApp',
          scopeType: 'release',
          data_keys: [
            'FormattedID',
            '_type',
            'Name',
            'PlanEstimate',
            'Tags',
            'RevisionHistory',
            'Revisions'
          ],
          columns: {
            'FormattedID': { key: 'FormattedID',    center: true },
            'Type':        { key: '_type',          center: true },
            'Name':        { key: 'Name',           center: false },
            'Estimate':    { key: 'PlanEstimate',   center: true },
            'Created':     { key: 'CreatedDate',    center: true, date: true },
            'Started':     { key: 'StartedDate',    center: true, date: true },
            'Completed':   { key: 'CompletedDate',  center: true, date: true },
            'Accepted':    { key: 'AcceptedDate',   center: true, date: true },
            'Released':    { key: 'ReleasedDate',   center: true, date: true}
          },

          launch: function() {
            this._mask = new Ext.LoadMask(Ext.getBody(), {
              msg: 'Please wait...'
            });
            this._mask.show();
            this.fetch_iterations(this.getContext().getTimeboxScope());
          },

          onTimeboxScopeChange: function(ts) {
            this._mask.show();
            this.fetch_iterations(ts);
          },

          // Create a list of filters, one for each iteration in the selected
          // quarter.
          fetch_iterations: function(ts) {
            var start = ts.record.raw.ReleaseStartDate;
            var end = ts.record.raw.ReleaseDate;
            var start_filter = Ext.create('Rally.data.wsapi.Filter', {
              property: 'StartDate',
              operator: '>=',
              value: start
            });
            var end_filter = Ext.create('Rally.data.wsapi.Filter', {
              property: 'StartDate',
              operator: '<',
              value: end
            });

            var store = Ext.create('Rally.data.wsapi.Store', {
              model: 'Iteration',
              fetch: ['Name']
            }, this);
            store.addFilter([start_filter, end_filter], false);
            store.load({
              scope: this,
              callback: function(records, operation) {
                if (operation.wasSuccessful()) {
                  var filters = records.map(function(r) {
                    return Ext.create('Rally.data.wsapi.Filter', {
                      property: 'Iteration.Name',
                      value: r.get('Name')
                    });
                  });
                  this.fetch_stories(filters, []);
                }
              }
            });
          },

          // Recursively fetch stories for each iteration filter and add them
          // all together.
          fetch_stories: function(filters, stories) {
            var store = Ext.create('Rally.data.wsapi.artifact.Store', {
              models: ['UserStory', 'Defect'],
              fetch: this.data_keys
            }, this);
            store.addFilter(filters[0])
            store.load({
              scope: this,
              callback: function(records, operation) {
                filters.shift();
                if (filters.length > 0) {
                  this.fetch_stories(filters,
                    operation.wasSuccessful() ?
                      stories.concat(records) :
                      stories
                  );
                } else {
                  this.fetch_revisions(stories, 0);
                }
              }
            });
          },

          // Recursively fetch the revisions for each story.
          fetch_revisions: function(stories, index) {
            var story = stories[index];
            var rh_split = story.get('RevisionHistory')._ref.split('/');
            var rh_oid = parseInt(rh_split[rh_split.length - 1]);
            var store = Ext.create('Rally.data.wsapi.Store', {
              model: 'Revision',
              sorters: [{
                property: 'RevisionNumber',
                direction: 'ASC'
              }]
            }, this);
            var rh_filter = Ext.create('Rally.data.wsapi.Filter', {
              property: 'RevisionHistory.ObjectID',
              value: rh_oid
            });
            store.addFilter(rh_filter);
            store.load({
              scope: this,
              callback: function(records, operation) {
                if (operation.wasSuccessful()) {
                  story.data.Revisions = records.map(function(r) {
                    return r.data;
                  });
                }

                if (index < stories.length - 1) {
                  this.fetch_revisions(stories, index + 1);
                } else {
                  this.get_story_data(stories, []);
                }
              }
            });
          },

          // Recursively reformat the data for each story. Once they're all
          // reformatted, pass the data along to the table building function.
          get_story_data: function(raw_stories, stories) {
            var raw_story = raw_stories[0];
            var story = {};
            this.data_keys.forEach(function(k) {
              story[k] = raw_story.get(k);
            });

            // Make the tags readable.
            story.Tags = story.Tags._tagsNameArray.map(function(o) {
              return o.Name;
            });

            // Make the type more readable.
            // Color the row based on the type.
            if (story._type == 'hierarchicalrequirement') {
              story._type = 'S';
              story.color = '#ffffff';
            } else if (story._type == 'defect') {
              if (story.Tags.indexOf('Customer Voice') == -1) {
                story._type = 'D';
                story.color = '#ffa500';
              } else {
                story._type = 'C';
                story.color = '#ff83fa';
              }
            }

            // Calculate the transition dates.
            var created, started, completed, accepted, released;
            story.Revisions.forEach(function(r) {
              if (r.Description == 'Original revision') {
                created = r.CreationDate;
              } else {
                var m = r.Description
                  .match(/SCHEDULE STATE changed from \[(.*?)\] to \[(.*?)\]/);

                if (m) {
                  if (m[2] == 'Idea') {
                    started = null;
                    completed = null;
                    accepted = null;
                    released = null;
                  } else if (m[2] == 'Defined') {
                    started = null;
                    completed = null;
                    accepted = null;
                    released = null;
                  } else if (m[2] == 'In-Progress') {
                    started = r.CreationDate;
                    completed = null;
                    accepted = null;
                    released = null;
                  } else if (m[2] == 'Completed') {
                    completed = r.CreationDate;
                    accepted = null;
                    released = null;
                  } else if (m[2] == 'Accepted') {
                    accepted = r.CreationDate;
                    released = null;
                  } else if (m[2] == 'Released') {
                    released = r.CreationDate;
                  }
                }
              }
            });
            if (created) {
              story.CreatedDate = created;
            }
            if (started) {
              story.StartedDate = started;
            }
            if (completed) {
              story.CompletedDate = completed;
            }
            if (accepted) {
              story.AcceptedDate = accepted;
            }
            if (released) {
              story.ReleasedDate = released;
            }

            // Process the next story.
            stories.push(story);
            raw_stories.shift();
            if (raw_stories.length > 0) {
              this.get_story_data(raw_stories, stories);
            } else {
              this.build_table(stories);
            }
          },

          // Construct the HTML table to display the story data.
          build_table: function(stories) {
            var table = '<table><thead><tr><th>' +
              Object.keys(this.columns).join('</th><th>') +
              '</th></tr></thead>';
            var that = this;
            stories.forEach(function(story) {
              table += that.build_table_row(story);
            });
            table += '</table>';

            this.removeAll();
            this.add({
              xtype: 'component',
              html: table
            });
            this._mask.hide();
          },

          // Given a story object, build an HTML row showing the relevant data.
          build_table_row: function(story) {
            var data = story;
            var row = '<tr>';
            var that = this;

            Object.keys(this.columns).forEach(function(col) {
              var datum = data[that.columns[col].key];
              var center = that.columns[col].center;
              if (!datum) {
                datum = '';
              } else if (that.columns[col].date) {
                datum = datum.toDateString();
              }

              row += ('<td ' +
                (center ? 'class = "center" ' : '') +
                ('bgcolor="' + data.color + '" ') +
                '>' +
                datum +
                '</td>'
              );
            });

            return row;
          }
        });

        Rally.launchApp('ZzacksApp');
      });
    </script>

    <style type="text/css">
      table {
        border-collapse: collapse;
      }

      td, th {
        border: 1px solid black;
      }

      .center {
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div>You shouldn't be able to see this! (*ﾉωﾉ)</div>
  </body>
</html>
