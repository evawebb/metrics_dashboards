<!DOCTYPE html>
<html>
  <head>
    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
      function toggle_big_table() {
        var t = document.getElementById("big_table");
        var l = document.getElementById("toggle_link");
        if (t.style.display == "inline") {
          t.style.display = "none";
          l.innerHTML = "Show all stories";
        } else {
          t.style.display = "inline";
          l.innerHTML = "Hide all stories";
        }
      }

      Rally.onReady(function () {
        Ext.define('ZzacksAllWorkDashboardApp', {
  extend: 'Rally.app.TimeboxScopedApp',
  scopeType: 'release',
  releases: [
    {
      name: '2016 Q4',
      start_date: new Date('10/10/2016 12:00 AM MDT'),
      end_date: new Date('01/13/2017 11:59 PM MST')
    },
    {
      name: '2016 Q3',
      start_date: new Date('07/18/2016 12:00 AM MDT'),
      end_date: new Date('10/07/2016 11:59 PM MDT')
    },
    {
      name: '2016 Q2',
      start_date: new Date('04/25/2016 12:00 AM MDT'),
      end_date: new Date('07/15/2016 11:59 PM MDT')
    },
    {
      name: '2016 Q1',
      start_date: new Date('01/18/2016 12:00 AM MST'),
      end_date: new Date('04/22/2016 11:59 PM MDT')
    }
  ],
  colors: {
    '2016 Q4': '#0000ff',
    '2016 Q3': '#ff0000',
    '2016 Q2': '#c0c000',
    '2016 Q1': '#00ffc0'
  },

  getUserSettingsFields: function() {
    return [];
  },

  onSettingsUpdate: function(settings) {
    console.log('Settings update:', settings);
  },

  launch: function() {
    this._mask = new Ext.LoadMask(Ext.getBody(), {
      msg: 'Please wait...'
    });
    this._mask.show();

    this.fetch_artifacts({
      UserStory: {},
      Defect: {}
    }, 3, 'UserStory');
  },

  haltEarly: function(msg) {
    this._mask.hide();
    this.removeAll();
    this.add({
      xtype: 'component',
      html: 'Error: ' + msg
    });
  },

  fetch_artifacts: function(artifacts, release_index, type) {
    this._mask.msg = 'Fetching artifacts...';
    this._mask.show();

    var that = this;
    var store = Ext.create('Rally.data.wsapi.artifact.Store', { 
      models: [type],
      filters: [
        {
          property: 'AcceptedDate',
          operator: '>=',
          value: that.releases[release_index].start_date
        },
        {
          property: 'AcceptedDate',
          operator: '<',
          value: that.releases[release_index].end_date
        }
      ]
    }, this);
    var t1 = new Date();
    store.load({
      scope: this,
      limit: 1500,
      callback: function(records, operation) {
        var t2 = new Date();
        console.log('Artifacts query took', (t2 - t1), 'ms, and retrieved', records ? records.length : 0, 'results.');

        if (operation.wasSuccessful()) {
          artifacts[type][that.releases[release_index].name] = records;
        }

        if (release_index > 0) {
          that.fetch_artifacts(artifacts, release_index - 1, type);
        } else {
          if (type == 'UserStory') {
            that.fetch_artifacts(artifacts, that.releases.length - 1, 'Defect');
          } else {
            that.calculate_deltas(artifacts);
          }
        }
      }
    });
  },

  calculate_deltas: function(artifacts) {
    this._mask.msg = 'Calculating release deltas...';
    this._mask.show();

    var that = this;
    var deltas = {};
    that.releases.forEach(function(r) {
      var r_deltas = {};
      var now = new Date();
      if (new Date(r.end_date) < now) {
        now = new Date(r.end_date);
      }
      for (var d = new Date(r.start_date); d <= now; d.setDate(d.getDate() + 1)) {
        r_deltas[d.toDateString()] = {
          accepted_pts: {
            UserStory: 0,
            Defect: 0
          },
          accepted_stories: {
            UserStory: 0,
            Defect: 0
          }
        };
      }
      deltas[r.name] = r_deltas;
    });

    Object.keys(artifacts.UserStory).forEach(function(r) {
      artifacts.UserStory[r].forEach(function(s) {
        var a_date = s.get('AcceptedDate').toDateString();
        if (a_date && deltas[r][a_date]) {
          deltas[r][a_date].accepted_pts.UserStory += s.get('PlanEstimate');
          deltas[r][a_date].accepted_stories.UserStory += 1;
        } else {
          console.log('Weird story!', s);
        }
      });
    });

    Object.keys(artifacts.Defect).forEach(function(r) {
      artifacts.Defect[r].forEach(function(s) {
        var a_date = s.get('AcceptedDate').toDateString();
        if (a_date && deltas[r][a_date]) {
          deltas[r][a_date].accepted_pts.Defect += s.get('PlanEstimate');
          deltas[r][a_date].accepted_stories.Defect += 1;
        } else {
          console.log('Weird story!', s);
        }
      });
    });

    Object.keys(deltas).forEach(function(r) {
      var d_first = Object.keys(deltas[r])[0];
      deltas[r][d_first].accepted_pts.Both =
        deltas[r][d_first].accepted_pts.UserStory +
        deltas[r][d_first].accepted_pts.Defect;
      deltas[r][d_first].accepted_stories.Both =
        deltas[r][d_first].accepted_stories.UserStory +
        deltas[r][d_first].accepted_stories.Defect;
      for (var i = 0; i < Object.keys(deltas[r]).length - 1; i += 1) {
        var d_prev = Object.keys(deltas[r])[i];
        var d_next = Object.keys(deltas[r])[i + 1];
        deltas[r][d_next].accepted_pts.UserStory += deltas[r][d_prev].accepted_pts.UserStory;
        deltas[r][d_next].accepted_stories.UserStory += deltas[r][d_prev].accepted_stories.UserStory;
        deltas[r][d_next].accepted_pts.Defect += deltas[r][d_prev].accepted_pts.Defect;
        deltas[r][d_next].accepted_stories.Defect += deltas[r][d_prev].accepted_stories.Defect;
        deltas[r][d_next].accepted_pts.Both =
          deltas[r][d_next].accepted_pts.UserStory +
          deltas[r][d_next].accepted_pts.Defect;
        deltas[r][d_next].accepted_stories.Both =
          deltas[r][d_next].accepted_stories.UserStory +
          deltas[r][d_next].accepted_stories.Defect;
      }
    });

    this.removeAll();
    this.create_options(deltas);
  },

  create_options: function(deltas) {
    var that = this;
    this.add({
      xtype: 'rallycombobox',
      itemId: 'artifact_select',
      fieldLabel: 'Artifact type(s):',
      store: ['Just stories', 'Just defects', 'Both'],
      listeners: {
        change: {
          fn: that.change_story_types.bind(that)
        }
      }
    });
    this.add({
      xtype: 'rallycombobox',
      itemId: 'graph_select',
      fieldLabel: 'Y-axis:',
      store: ['Total points', 'Total stories/defects'],
      listeners: { change: {
        fn: that.change_graph_type.bind(that)
      }}
    });

    this.deltas = deltas;
    this.artifact_type = 'UserStory';
    this.graph_type = 'Total points';

    this.build_charts(deltas, this.graph_type, this.artifact_type);
  },

  build_charts: function(deltas, graph_type, artifact_type) {
    this._mask.msg = 'Building chart...';
    this._mask.show();

    var points = graph_type == 'Total points';

    var that = this;
    var series = [];
    Object.keys(deltas).forEach(function(release) {
      var data = [];

      Object.keys(deltas[release]).forEach(function(d) {
        data.push({
          y: points ?
            deltas[release][d].accepted_pts[artifact_type] :
            deltas[release][d].accepted_stories[artifact_type],
          date: d
        });
      });

      series.push({
        name: release,
        color: that.colors[release],
        data: data
      });
    });

    var title_type = 'Stories';
    if (artifact_type == 'Defect') {
      title_type = 'Defects';
    } else if (artifact_type == 'Both') {
      title_type = 'Both';
    }

    var chart_config = {
      chart: { type: 'line' },
      xAxis: { 
        title: { text: 'Days into the quarter' }
      },
      plotOptions: { line: {
        lineWidth: 3,
        marker: { enabled: false }
      }}
    };
    var tooltip_header = '<span style="font-size: 10px">{series.name}</span><br/>';
    var tooltip_point = '<b>{point.y} {unit}</b><br />on {point.date}';

    that.chart = this.add({
      xtype: 'rallychart',
      loadMask: false,
      chartData: {
        series: series.reverse()
      },
      chartConfig: Object.assign(
        {
          title: { text: (points ? 'Points' : 'Stories/defects') + ' accepted per quarter (' + title_type + ')' },
          yAxis: { 
            title: { text: 'Total ' + (points ? 'points' : 'artifacts') },
            min: 0
          },
          tooltip: {
            headerFormat: tooltip_header,
            pointFormat: tooltip_point.replace('{unit}', points ? 'points' : 'artifacts')
          }
        },
        chart_config
      )
    });

    this._mask.hide();
  },

  change_story_types: function(t, new_item, old_item, e) {
    if (old_item && this.chart) {
      if (new_item == 'Just stories') {
        this.artifact_type = 'UserStory';
        this.remove(this.chart);
        this.build_charts(this.deltas, this.graph_type, 'UserStory');
      } else if (new_item == 'Just defects') {
        this.artifact_type = 'Defect';
        this.remove(this.chart);
        this.build_charts(this.deltas, this.graph_type, 'Defect');
      } else {
        this.artifact_type = 'Both';
        this.remove(this.chart);
        this.build_charts(this.deltas, this.graph_type, 'Both');
      }
    }
  },

  change_graph_type: function(t, new_item, old_item, e) {
    if (old_item && this.chart) {
      this.graph_type = new_item;
      this.remove(this.chart);
      this.build_charts(this.deltas, new_item, this.artifact_type);
    }
  }
});

Ext.define('ZzacksFeatureDashboardApp', {
  extend: 'Rally.app.TimeboxScopedApp',
  scopeType: 'release',
  releases: [
    {
      name: '2016 Q4',
      start_date: new Date('10/10/2016 12:00 AM MDT'),
      end_date: new Date('01/13/2017 11:59 PM MST')
    },
    {
      name: '2016 Q3',
      start_date: new Date('07/18/2016 12:00 AM MDT'),
      end_date: new Date('10/07/2016 11:59 PM MDT')
    },
    {
      name: '2016 Q2',
      start_date: new Date('04/25/2016 12:00 AM MDT'),
      end_date: new Date('07/15/2016 11:59 PM MDT')
    },
    {
      name: '2016 Q1',
      start_date: new Date('01/18/2016 12:00 AM MST'),
      end_date: new Date('04/22/2016 11:59 PM MDT')
    }
  ],
  colors: {
    '2016 Q4': '#0000ff',
    '2016 Q3': '#ff0000',
    '2016 Q2': '#c0c000',
    '2016 Q1': '#00ffc0'
  },
  drops: {
    //61568308539: new Date('10/30/2016 12:00 AM MST').toDateString()
  },
  histories_cluster_size: 300,

  getUserSettingsFields: function() {
    return []
  },

  onSettingsUpdate: function(settings) {
    console.log('Settings update:', settings);
  },

  launch: function() {
    this._mask = new Ext.LoadMask(Ext.getBody(), {
      msg: 'Please wait...'
    });
    this._mask.show();

    var release_names = this.releases.map(function(r) {
      return r.name;
    });
    this.fetch_committed_features(release_names, [], {});
  },

  haltEarly: function(msg) {
    this._mask.hide();
    this.removeAll();
    this.add({
      xtype: 'component',
      html: 'Error: ' + msg
    });
  },

  fetch_committed_features: function(release_names, features, release_lookups) {
    this._mask.msg = 'Fetching features... (' + release_names.length + ' releases left)';
    this._mask.show();

    var that = this;
    
    var store = Ext.create('Rally.data.wsapi.artifact.Store', {
      models: ['PortfolioItem/Feature'],
      fetch: ['Name', 'Release'],
      filters: [
        {
          property: 'Release.Name',
          value: release_names[0]
        }
      ]
    }, this);
    var t1 = new Date();
    store.load({
      scope: this,
      callback: function(records, operation) {
        var t2 = new Date();
        console.log('Committed features query took', (t2 - t1), 'ms, and retrieved', records ? records.length : 0, 'results.');
        if (operation.wasSuccessful()) {
          records.forEach(function(r) {
            release_lookups[r.get('Name')] = release_names[0];
          });
          features = features.concat(records);
        }
        release_names.shift();

        if (release_names.length > 0) {
          this.fetch_committed_features(release_names, features, release_lookups);
        } else {
          this.fetch_unscheduled_features(features, release_lookups, 0, []);
        }
      }
    });
  },

  fetch_unscheduled_features: function(features, release_lookups, index, unsched_features) {
    this._mask.msg = 'Fetching unscheduled features...';
    this._mask.show();
    var that = this;

    var store = Ext.create('Rally.data.wsapi.artifact.Store', {
      models: ['PortfolioItem/Feature'],
      fetch: ['Name', 'Release', 'ObjectID', 'RevisionHistory'],
      filters: [
        {
          property: 'Release.Name',
          value: null
        },
        {
          property: 'LastUpdateDate',
          operator: '>=',
          value: that.releases[index].start_date
        }
      ]
    }, this);
    var t1 = new Date();
    store.load({
      scope: this,
      limit: 1500,
      callback: function(records, operation) {
        var t2 = new Date();
        console.log('Unscheduled features query took', (t2 - t1), 'ms, and retrieved', records ? records.length : 0, 'results.');

        if (operation.wasSuccessful()) {
          unsched_features = unsched_features.concat(records);
        }

        if (index + 1 < that.releases.length) {
          that.fetch_unscheduled_features(features, release_lookups, index + 1, unsched_features);
        } else {
          that.fetch_unschedule_dates(features, release_lookups, unsched_features);
        }
      }
    });
  },

  fetch_unschedule_dates(features, release_lookups, unsched_features) {
    this._mask.msg = 'Calculating unscheduled feature dates... (' + unsched_features.length + ' features left)';
    this._mask.show();
    var that = this;

    var store = Ext.create('Rally.data.wsapi.Store', {
      model: 'Revision',
      fetch: ['Description', 'CreationDate'],
      filters: [
        {
          property: 'RevisionHistory.ObjectID',
          value: unsched_features[0].get('RevisionHistory')
            ._ref.split('/').reverse()[0]
        }
      ],
      sorters: [
        {
          property: 'RevisionNumber',
          direction: 'ASC'
        }
      ]
    }, this);
    var t1 = new Date();
    store.load({
      scope: this,
      callback: function(records, operation) {
        var t2 = new Date();
        console.log('Unscheduled dates query took', (t2 - t1), 'ms, and retrieved', records ? records.length : 0, 'results.');
        var relevant = false;
        if (operation.wasSuccessful()) {
          var r_filt = records.filter(function(r) {
            return r.get('Description').match(/RELEASE removed/);
          });
          
          if (r_filt.length > 0) {
            relevant = true;
            r_filt.forEach(function(r) {
              release_lookups[unsched_features[0].get('Name')] = 
                r.get('Description').match(/RELEASE removed \[(.*?)\]/)[1];
              that.drops[unsched_features[0].get('ObjectID')] = 
                r.get('CreationDate').toDateString();
            });
          }
        }

        if (relevant) {
          features.push(unsched_features.shift());
        } else {
          unsched_features.shift();
        }
        if (unsched_features.length > 0) {
          this.fetch_unschedule_dates(features, release_lookups, unsched_features);
        } else {
          this.fetch_stories(features, [], release_lookups);
        }
      }
    });
  },

  fetch_stories: function(features, stories, release_lookups) {
    this._mask.msg = 'Fetching stories... (' + features.length + ' features left)';
    this._mask.show();

    var that = this;
    var store = Ext.create('Rally.data.wsapi.artifact.Store', {
      models: ['UserStory', 'Defect'],
      filters: [
        {
          property: 'Feature.ObjectID',
          value: features[0].get('ObjectID')
        },
        {
          property: 'DirectChildrenCount',
          value: 0
        }
      ]
    }, this);
    var t1 = new Date();
    store.load({
      scope: this,
      callback: function(records, operation) {
        var t2 = new Date();
        console.log('Stories query took', (t2 - t1), 'ms, and retrieved', records ? records.length : 0, 'results.');
        if (operation.wasSuccessful()) {
          stories = stories.concat(records);
        }
        features.shift();

        if (features.length > 0) {
          this.fetch_stories(features, stories, release_lookups);
        } else {
          this.fetch_histories(stories, 0, {}, release_lookups);
        }
      }
    });
  },

  fetch_histories: function(stories, index, release_dates, release_lookups) {
    this._mask.msg = 'Fetching story histories... (' + (stories.length - index) + ' stories left)';
    this._mask.show();

    var story_oids = stories.slice(index, index + this.histories_cluster_size)
      .map(function(s) {
        return s.get('ObjectID');
      });

    var that = this;
    var t1 = new Date();
    var store = Ext.create('Rally.data.lookback.SnapshotStore', {
      fetch: [
        'Name', 'FormattedID', 'ScheduleState', 
        '_PreviousValues.ScheduleState', 
        'PlanEstimate', '_ValidFrom'
      ],
      hydrate: ['ScheduleState', '_PreviousValues.ScheduleState'],
      filters: [
        {
          property: 'ObjectID',
          operator: 'in',
          value: story_oids
        }
      ],
      listeners: {
        load: function(store, data, success) {
          var t2 = new Date();
          console.log('Story histories query took', (t2 - t1), 'ms, and retrieved', data ? data.length : 0, 'results.');
          if (success) {
            data.filter(function(d) {
              return (
                (
                  d.get('_PreviousValues.ScheduleState')
                  && d.get('_PreviousValues.ScheduleState').length > 0
                )
                || d.get('_PreviousValues.ScheduleState') === null
              );
            }).forEach(function(d) {
              var fid = d.get('FormattedID');
              if (d.get('ScheduleState') == 'Released') {
                release_dates[fid] = new Date(d.get('_ValidFrom')).toDateString();
              } else {
                delete release_dates[fid];
              }
            });
            
            if (index + that.histories_cluster_size < stories.length) {
              that.fetch_histories(
                stories, 
                index + that.histories_cluster_size, 
                release_dates, 
                release_lookups
              );
            } else {
              that.construct_series(
                release_dates, 
                stories, 
                release_lookups
              );
            }
          }
        }
      }
    });
    t1 = new Date();
    store.load({ scope: this });
  },

  construct_series: function(release_dates, stories, release_lookups) {
    var that = this;
    var deltas = {};
    this.releases.forEach(function(r) {
      var r_deltas = {};
      var now = new Date();
      if (new Date(r.end_date) < now) {
        now = new Date(r.end_date);
      }
      for (var d = new Date(r.start_date); d <= now; d.setDate(d.getDate() + 1)) {
        r_deltas[d.toDateString()] = {
          released_pts: 0,
          created_pts: 0,
          released_stories: 0,
          created_stories: 0
        };
      }
      deltas[r.name] = r_deltas;
    });

    stories.forEach(function(s) {
      var release = release_lookups[s.get('Feature').Name];
      if (deltas.hasOwnProperty(release)) {
        var r_date = release_dates[s.get('FormattedID')];
        var c_date = s.get('CreationDate').toDateString();
        var drop = that.drops[s.get('Feature').ObjectID];

        if (
          r_date && deltas[release][r_date]
          && (
            !drop
            || (
              drop 
              && deltas[release][drop]
              && (new Date(drop) > new Date(r_date))
            )
          )
        ) {
          deltas[release][r_date].released_pts += s.get('PlanEstimate');
          deltas[release][r_date].released_stories += 1;

          if (drop) {
            deltas[release][drop].released_pts -= s.get('PlanEstimate');
            deltas[release][drop].released_stories -= 1;
          }
        }

        if (c_date && deltas[release]) {
          if (!drop || deltas[release][drop]) {
            if (deltas[release][c_date]) {
              deltas[release][c_date].created_pts += s.get('PlanEstimate');
              deltas[release][c_date].created_stories += 1;
            } else {
              deltas[release][Object.keys(deltas[release])[0]].created_pts += s.get('PlanEstimate');
              deltas[release][Object.keys(deltas[release])[0]].created_stories += 1;
            }
          }

          if (drop && deltas[release][drop]) {
            deltas[release][drop].created_pts -= s.get('PlanEstimate');
            deltas[release][drop].created_stories -= 1;
          }
        }
      }
    });

    Object.keys(deltas).forEach(function(r) {
      var r_deltas = deltas[r];
      for (var i = 0; i < Object.keys(r_deltas).length - 1; i += 1) {
        var d_prev = Object.keys(r_deltas)[i];
        var d_next = Object.keys(r_deltas)[i + 1];
        r_deltas[d_next].released_pts += r_deltas[d_prev].released_pts;
        r_deltas[d_next].released_stories += r_deltas[d_prev].released_stories;
        r_deltas[d_next].created_pts += r_deltas[d_prev].created_pts;
        r_deltas[d_next].created_stories += r_deltas[d_prev].created_stories;
      }
    });
    this.removeAll();
    this.create_options(deltas);
  },

  create_options: function(deltas) {
    var that = this;
    this.add({
      xtype: 'rallycombobox',
      itemId: 'graph_select',
      fieldLabel: 'Y-axis:',
      store: ['Total points', 'Total stories/defects'],
      listeners: { change: {
        fn: that.change_graph_type.bind(that)
      }}
    });

    this.deltas = deltas;
    this.build_charts(deltas, 'Total points');
  },

  build_charts: function(deltas, type) {
    this._mask.msg = 'Building chart...';
    this._mask.show();

    var points = type == 'Total points';

    var that = this;
    var series = [];
    Object.keys(deltas).forEach(function(release) {
      var released_config = {
        name: release,
        color: that.colors[release]
      };
      var created_config = {
        name: release + ' Scope',
        color: that.colors[release],
        dashStyle: 'Dot',
        visible: release == that.releases[0].name
      };
      var released_data = [];
      var created_data = [];

      Object.keys(deltas[release]).forEach(function(d) {
        released_data.push({
          y: points ?
            deltas[release][d].released_pts :
            deltas[release][d].released_stories,
          date: d
        });
        created_data.push({
          y: points ?
            deltas[release][d].created_pts :
            deltas[release][d].created_stories,
          date: d
        });
      });

      series.push(Object.assign(
        { data: released_data },
        released_config
      ));
      series.push(Object.assign(
        { data: created_data },
        created_config
      ));
    });

    var chart_config = {
      chart: { type: 'line' },
      title: { text: (points ? 'Points' : 'Stories/defects') + ' released for features this quarter' },
      xAxis: { 
        title: { text: 'Days into the quarter' }
      },
      yAxis: { 
        title: { text: 'Total ' + (points ? 'points' : 'artifacts') },
        min: 0
      },
      tooltip: {
        headerFormat: '<span style="font-size: 10px">{series.name}</span><br/>',
        pointFormat: '<b>{point.y} {unit}</b><br />on {point.date}'.replace('{unit}', points ? 'points' : 'artifacts')
      },
      plotOptions: { line: {
        lineWidth: 3,
        marker: { enabled: false }
      }}
    };

    this.chart = this.add({
      xtype: 'rallychart',
      loadMask: false,
      chartData: {
        series: series.reverse()
      },
      chartConfig: chart_config
    });
     
    this._mask.hide();
  },

  change_graph_type: function(t, new_item, old_item, e) {
    if (old_item && this.chart) {
      this.remove(this.chart);
      this.build_charts(this.deltas, new_item);
    }
  }
});

Ext.define('ZzacksInitiativeDashboardApp', {
  extend: 'Rally.app.TimeboxScopedApp',
  scopeType: 'release',
  drops: {},
  histories_cluster_size: 300,

  getUserSettingsFields: function() {
    return [{
      name: 'Initiative',
      xtype: 'rallyartifactsearchcombobox',
      storeConfig: {
        models: ['PortfolioItem/Initiative']
      }
    }];
  },

  onSettingsUpdate: function(settings) {
    this.fetch_initiative(this.ts);
  },

  launch: function() {
    this._mask = new Ext.LoadMask(Ext.getBody(), {
      msg: 'Please wait...'
    });
    this._mask.show();

    if (!this.getSettings().Initiative) {
      this.getSettings().Initiative = '/portfolioitem/initiative/44772028590';
    }
    this.ts = this.getContext().getTimeboxScope();
    this.fetch_initiative(this.ts);
  },

  onTimeboxScopeChange: function(ts) {
    this._mask = new Ext.LoadMask(Ext.getBody(), {
      msg: 'Please wait...'
    });
    this._mask.show();

    this.ts = ts;
    this.fetch_initiative(ts);
  },

  haltEarly: function(msg) {
    this._mask.hide();
    this.removeAll();
    this.add_settings_link();
    this.add({
      xtype: 'component',
      html: 'Error: ' + msg
    });
  },

  fetch_initiative: function(ts) {
    this._mask.msg = 'Fetching initiative...';
    this._mask.show();

    var that = this;

    var store = Ext.create('Rally.data.wsapi.artifact.Store', {
      models: ['PortfolioItem/Initiative'],
      filters: {
        property: 'ObjectID',
        value: parseInt(that.getSettings().Initiative.split('/').reverse()[0])
      }
    }, this);
    store.load({
      scope: this,
      callback: function(records, operation) {
        if (operation.wasSuccessful() && records[0]) {
          that.fetch_committed_features(records[0].data, ts);
        } else {
          that.haltEarly('Problem loading initiative.');
        }
      }
    });
  },

  fetch_committed_features: function(initiative, ts) {
    this._mask.msg = 'Fetching features...';
    this._mask.show();

    var that = this;
    
    var store = Ext.create('Rally.data.wsapi.artifact.Store', {
      models: ['PortfolioItem/Feature'],
      fetch: ['Name', 'Release'],
      filters: [
        {
          property: 'Release.Name',
          value: ts.record.raw.Name
        },
        {
          property: 'Parent.FormattedID',
          value: initiative.FormattedID
        }
      ]
    }, this);
    var t1 = new Date();
    store.load({
      scope: this,
      callback: function(records, operation) {
        var t2 = new Date();
        console.log('Committed features query took', (t2 - t1), 'ms, and retrieved', records ? records.length : 0, 'results.');
        if (operation.wasSuccessful()) {
          if (records.length > 0) {
            that.fetch_unscheduled_features(records, initiative, ts);
          } else {
            that.haltEarly('No features found.');
          }
        }
      }
    });
  },

  fetch_unscheduled_features: function(features, initiative, ts) {
    this._mask.msg = 'Fetching unscheduled features...';
    this._mask.show();
    var that = this;

    var store = Ext.create('Rally.data.wsapi.artifact.Store', {
      models: ['PortfolioItem/Feature'],
      fetch: ['Name', 'Release', 'ObjectID', 'RevisionHistory'],
      filters: [
        {
          property: 'Release.Name',
          operator: '!=',
          value: ts.record.raw.Name
        },
        {
          property: 'Parent.FormattedID',
          value: initiative.FormattedID
        }
      ]
    }, this);
    var t1 = new Date();
    store.load({
      scope: this,
      callback: function(records, operation) {
        var t2 = new Date();
        console.log('Unscheduled features query took', (t2 - t1), 'ms, and retrieved', records ? records.length : 0, 'results.');

        if (records && records.length > 0) {
          this.fetch_unschedule_dates(features, records, initiative, ts);
        } else {
          this.fetch_stories(features, [], initiative, ts);
        }
      }
    });
  },

  fetch_unschedule_dates(features, unsched_features, initiative, ts) {
    this._mask.msg = 'Calculating unscheduled feature dates... (' + unsched_features.length + ' features left)';
    this._mask.show();
    var that = this;

    var store = Ext.create('Rally.data.wsapi.Store', {
      model: 'Revision',
      fetch: ['Description', 'CreationDate'],
      filters: [
        {
          property: 'RevisionHistory.ObjectID',
          value: unsched_features[0].get('RevisionHistory')
            ._ref.split('/').reverse()[0]
        }
      ],
      sorters: [
        {
          property: 'RevisionNumber',
          direction: 'ASC'
        }
      ]
    }, this);
    var t1 = new Date();
    store.load({
      scope: this,
      callback: function(records, operation) {
        var t2 = new Date();
        console.log('Unscheduled dates query took', (t2 - t1), 'ms, and retrieved', records ? records.length : 0, 'results.');
        var relevant = false;
        if (operation.wasSuccessful()) {
          var r_filt = records.filter(function(r) {
            return r.get('Description').match(new RegExp(
              'RELEASE (removed|changed from) \['
              + ts.record.raw.Name
              + '\]'
            ));
          });
          
          if (r_filt.length > 0) {
            relevant = true;
            r_filt.forEach(function(r) {
              that.drops[unsched_features[0].get('ObjectID')] = 
                r.get('CreationDate').toDateString();
            });
          }
        }

        if (relevant) {
          features.push(unsched_features.shift());
        } else {
          unsched_features.shift();
        }

        if (unsched_features.length > 0) {
          this.fetch_unschedule_dates(features, unsched_features, initiative, ts);
        } else {
          this.fetch_stories(features, [], initiative, ts);
        }
      }
    });
  },

  fetch_stories: function(features, stories, initiative, ts) {
    this._mask.msg = 'Fetching stories... (' + features.length + ' features left)';
    this._mask.show();

    var that = this;
    var store = Ext.create('Rally.data.wsapi.artifact.Store', {
      models: ['UserStory', 'Defect'],
      fetch: ['ObjectID', 'Name', 'PlanEstimate', 'FormattedID', 'Feature', 'CreationDate'],
      filters: [
        {
          property: 'Feature.Name',
          value: features[0].get('Name')
        },
        {
          property: 'DirectChildrenCount',
          value: 0
        }
      ]
    }, this);
    var t1 = new Date();
    store.load({
      scope: this,
      callback: function(records, operation) {
        var t2 = new Date();
        console.log('Stories query took', (t2 - t1), 'ms, and retrieved', records ? records.length : 0, 'results.');
        if (operation.wasSuccessful()) {
          stories = stories.concat(records);
        }
        features.shift();

        if (features.length > 0) {
          this.fetch_stories(features, stories, initiative, ts);
        } else {
          this.fetch_histories(stories, 0, {}, initiative, ts);
        }
      }
    });
  },

  fetch_histories: function(stories, index, release_dates, initiative, ts) {
    this._mask.msg = 'Fetching story histories... (' + (stories.length - index) + ' stories left)';
    this._mask.show();

    var story_oids = stories.slice(index, index + this.histories_cluster_size)
      .map(function(s) {
        return s.get('ObjectID');
      });

    var that = this;
    var t1 = new Date();
    var store = Ext.create('Rally.data.lookback.SnapshotStore', {
      fetch: [
        'Name', 'FormattedID', 'ScheduleState', 
        '_PreviousValues.ScheduleState', 
        'PlanEstimate', '_ValidFrom'
      ],
      hydrate: [
        'ScheduleState', 
        '_PreviousValues.ScheduleState'
      ],
      filters: [
        {
          property: 'ObjectID',
          operator: 'in',
          value: story_oids
        }
      ],
      listeners: {
        load: function(store, data, success) {
          var t2 = new Date();
          console.log('Story histories query took', (t2 - t1), 'ms, and retrieved', data ? data.length : 0, 'results.');
          if (success) {
            data.filter(function(d) {
              return (
                (
                  d.get('_PreviousValues.ScheduleState')
                  && d.get('_PreviousValues.ScheduleState').length > 0
                )
                || d.get('_PreviousValues.ScheduleState') === null
              );
            }).forEach(function(d) {
              var fid = d.get('FormattedID');
              if (d.get('ScheduleState') == 'Released') {
                release_dates[fid] = new Date(d.get('_ValidFrom')).toDateString();
              } else {
                delete release_dates[fid];
              }
            });
            
            if (index + that.histories_cluster_size < stories.length) {
              that.fetch_histories(
                stories, 
                index + that.histories_cluster_size, 
                release_dates,
                initiative,
                ts
              );
            } else {
              that.construct_series(
                release_dates, 
                stories,
                initiative,
                ts
              );
            }
          }
        }
      }
    });
    t1 = new Date();
    store.load({ scope: this });
  },

  construct_series: function(release_dates, stories, initiative, ts) {
    var that = this;
    var deltas = {};
    var now = new Date();
    if (new Date(ts.record.raw.ReleaseDate) < now) {
      now = new Date(ts.record.raw.ReleaseDate);
    }
    for (var d = new Date(ts.record.raw.ReleaseStartDate); d <= now; d.setDate(d.getDate() + 1)) {
      deltas[d.toDateString()] = {
        released_pts: 0,
        created_pts: 0,
        released_stories: 0,
        created_stories: 0
      };
    }

    stories.forEach(function(s) {
      var r_date = release_dates[s.get('FormattedID')];
      var c_date = s.get('CreationDate').toDateString();
      var drop = that.drops[s.get('Feature').ObjectID];

      if (r_date && deltas[r_date]) {
        deltas[r_date].released_pts += s.get('PlanEstimate');
        deltas[r_date].released_stories += 1;

        if (drop && deltas[drop]) {
          deltas[drop].released_pts -= s.get('PlanEstimate');
          deltas[drop].released_stories -= 1;
        }
      }

      if (c_date) {
        if (!drop || deltas[drop]) {
          if (deltas[c_date]) {
            deltas[c_date].created_pts += s.get('PlanEstimate');
            deltas[c_date].created_stories += 1;
          } else {
            deltas[Object.keys(deltas)[0]].created_pts += s.get('PlanEstimate');
            deltas[Object.keys(deltas)[0]].created_stories += 1;
          }
        }

        if (drop && deltas[drop]) {
          deltas[drop].created_pts -= s.get('PlanEstimate');
          deltas[drop].created_stories -= 1;
        }
      }
    });
    
    for (var i = 0; i < Object.keys(deltas).length - 1; i += 1) {
      var d_prev = Object.keys(deltas)[i];
      var d_next = Object.keys(deltas)[i + 1];
      deltas[d_next].released_pts += deltas[d_prev].released_pts;
      deltas[d_next].released_stories += deltas[d_prev].released_stories;
      deltas[d_next].created_pts += deltas[d_prev].created_pts;
      deltas[d_next].created_stories += deltas[d_prev].created_stories;
    }
    this.removeAll();
    this.create_options(deltas, initiative);
  },

  create_options: function(deltas, initiative) {
    var that = this;
    this.add({
      xtype: 'rallycombobox',
      itemId: 'graph_select',
      fieldLabel: 'Y-axis:',
      store: ['Total points', 'Total stories/defects'],
      listeners: { change: {
        fn: that.change_graph_type.bind(that)
      }}
    });
    this.add_settings_link();

    this.deltas = deltas;
    this.initiative = initiative;
    this.build_charts(deltas, initiative, 'Total points');
  },

  build_charts: function(deltas, initiative, type) {
    this._mask.msg = 'Building chart...';
    this._mask.show();

    var points = type == 'Total points';

    var that = this;
    var series = [];
    var released_config = {
      name: 'Released',
      color: '#0000ff'
    };
    var created_config = {
      name: 'Planned',
      color: '#0000ff',
      dashStyle: 'Dot'
    };
    var released_data = [];
    var created_data = [];

    Object.keys(deltas).forEach(function(d) {
      released_data.push({
        y: points ?
          deltas[d].released_pts :
          deltas[d].released_stories,
        date: d
      });
      created_data.push({
        y: points ?
          deltas[d].created_pts :
          deltas[d].created_stories,
        date: d
      });
    });

    series.push(Object.assign(
      { data: released_data },
      released_config
    ));
    series.push(Object.assign(
      { data: created_data },
      created_config
    ));

    var chart_config = {
      chart: { type: 'line' },
      xAxis: { 
        title: { text: 'Days into the quarter' }
      },
      plotOptions: { line: {
        lineWidth: 3,
        marker: { enabled: false }
      }}
    };
    var tooltip_header = '<span style="font-size: 10px">{series.name}</span><br/>';
    var tooltip_point = '<b>{point.y} {unit}</b><br />on {point.date}';

    this.chart = this.add({
      xtype: 'rallychart',
      loadMask: false,
      chartData: {
        series: series.reverse()
      },
      chartConfig: Object.assign(
        {
          title: { text: (points ? 'Points' : 'Stories/defects') + ' released for ' + initiative.FormattedID + ': ' + initiative.Name },
          yAxis: { 
            title: { text: 'Total ' + (points ? 'points' : 'artifacts')},
            min: 0
          },
          tooltip: {
            headerFormat: tooltip_header,
            pointFormat: tooltip_point.replace('{unit}', points ? 'points' : 'artifacts')
          }
        },
        chart_config
      )
    });

    this._mask.hide();
  },

  change_graph_type: function(t, new_item, old_item, e) {
    if (old_item && this.chart) {
      this.remove(this.chart);
      this.build_charts(this.deltas, this.initiative, new_item);
    }
  },

  add_settings_link: function() {
    this.add({
      xtype: 'component',
      html: '<a href="javascript:;" onClick="' +
            'Rally.getApp().showSettings()' +
            '">Modify app settings</a><br />'
    });
  }
});

Ext.define('ZzacksTeamDashboardApp', {
  extend: 'Rally.app.TimeboxScopedApp',
  scopeType: 'release',
  data_keys: [
    'FormattedID',
    '_type',
    'Name',
    'PlanEstimate',
    'Resolution',
    'Tags',
    'RevisionHistory',
    'Revisions',
    'CreationDate',
    'InProgressDate',
    'AcceptedDate',
    'Feature'
  ],
  cycle_time_start_state: 'Started',
  cycle_time_end_state: 'Released',
  columns_big: {
    'FormattedID':      { key: 'FormattedID',    center: true },
    'Type':             { key: '_type',          center: true },
    'Name':             { key: 'Name',           center: false },
    'Estimate':         { key: 'PlanEstimate',   center: true },
    'Created':          { key: 'CreatedDate',    center: true, date: true },
    'Defined':          { key: 'DefinedDate',    center: true, date: true },
    'Started':          { key: 'StartedDate',    center: true, date: true },
    'Completed':        { key: 'CompletedDate',  center: true, date: true },
    'Accepted':         { key: 'AcceptedDate',   center: true, date: true },
    'Released':         { key: 'ReleasedDate',   center: true, date: true },
    'Backtracks':       { key: 'BackCount',      center: true },
    'Skipped':          { key: 'Skipped',        center: true },
    'Cycle Time':       { key: 'CycleTime',      center: true },
    'Resolution':       { key: 'Resolution',     center: false }
  },
  columns_stats: {
    'Type':                 { key: 'name' },
    'Accepted Throughput':  { key: 'throughput_a',  label: true },
    'Released Throughput':  { key: 'throughput_r',  label: true, highlight: true },
    'Cycle Time Avg.':      { key: 'cycle_time',    time: true, highlight: true },
    'Cycle Time Median':    { key: 'median_ct',     time: true, highlight: true },
    'Weekly Released Avg.': { key: 'weekly_r',      label: true },
    'Skipped':              { key: 'skipped',       label: true }
  },
  months: [
    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
  ],
  complete_dates: true,
  cycle_time_threshold: 25,

  getUserSettingsFields: function() {
    return [
      {
        name: 'Cycle Time Start State',
        xtype: 'rallycombobox',
        editable: false,
        store: ['Created', 'Defined', 'Started', 'Completed', 'Accepted', 'Released']
      },
      {
        name: 'Cycle Time End State',
        xtype: 'rallycombobox',
        editable: false,
        store: ['Created', 'Defined', 'Started', 'Completed', 'Accepted', 'Released']
      }
    ];
  },

  onSettingsUpdate: function(settings) {
    if (
      settings['Cycle Time Start State'] != this.cycle_time_start_state
      || settings['Cycle Time End State'] != this.cycle_time_end_state
    ) {
      this.cycle_time_start_state = settings['Cycle Time Start State'];
      this.cycle_time_end_state = settings['Cycle Time End State'];
      this._mask.show();
      this.fetch_iterations(this.getContext().getTimeboxScope());
    }
  },

  launch: function() {
    if (this.getSettings()['Cycle Time Start State']) {
      this.cycle_time_start_state = this.getSettings()['Cycle Time Start State'];
    } else {
      this.getSettings()['Cycle Time Start State'] = this.cycle_time_start_state;
    }
    if (this.getSettings()['Cycle Time End State']) {
      this.cycle_time_end_state = this.getSettings()['Cycle Time End State'];
    } else {
      this.getSettings()['Cycle Time End State'] = this.cycle_time_end_state;
    }

    this._mask = new Ext.LoadMask(Ext.getBody(), {
      msg: 'Please wait...'
    });
    this._mask.show();
    this.fetch_iterations(this.getContext().getTimeboxScope());
  },

  onTimeboxScopeChange: function(ts) {
    this._mask.show();
    this.fetch_iterations(ts);
  },

  haltEarly: function(msg) {
    this._mask.hide();
    this.removeAll();
    this.add({
      xtype: 'component',
      html: 'Error: ' + msg
    });
  },

  // Fetch a list of the names of the iterations in this quarter.
  fetch_iterations: function(ts) {
    this._mask.msg = 'Fetching iterations...';
    this._mask.show();

    this.start_date = ts.record.raw.ReleaseStartDate;
    this.end_date = ts.record.raw.ReleaseDate;

    var store = Ext.create('Rally.data.wsapi.Store', {
      model: 'Iteration',
      fetch: ['Name', 'StartDate'],
      filters: [
        {
          property: 'StartDate',
          operator: '>=',
          value: this.start_date
        },
        {
          property: 'StartDate',
          operator: '<',
          value: this.end_date
        }
      ]
    }, this);
    var t1 = new Date();
    store.load({
      scope: this,
      callback: function(records, operation) {
        var t2 = new Date();
        console.log('Iterations query took', (t2 - t1), 'ms, and retrieved', records ? records.length : 0, 'results.');
        if (operation.wasSuccessful()) {
          this.num_iterations = records.filter(function(r) {
            return r.get('StartDate').getTime() < Date.now();
          }).length;

          var iterations = [];
          records.forEach(function(r) {
            if (!iterations.includes(r.get('Name'))) {
              iterations.push(r.get('Name'));
            }
          });

          if (iterations.length > 0) {
            this.fetch_stories(iterations, []);
          } else {
            this.haltEarly('No iterations found.');
          }
        }
      }
    });
  },

  // Recursively fetch stories for each iteration filter and add them
  // all together.
  fetch_stories: function(iterations, stories) {
    this._mask.msg = 'Fetching stories...';
    this._mask.show();

    var store = Ext.create('Rally.data.wsapi.artifact.Store', {
      models: ['UserStory', 'Defect'],
      fetch: this.data_keys,
      filters: [
        {
          property: 'Iteration.Name',
          value: iterations[0]
        }
      ]
    }, this);
    var t1 = new Date();
    store.load({
      scope: this,
      callback: function(records, operation) {
        var t2 = new Date();
        console.log('Stories query took', (t2 - t1), 'ms, and retrieved', records ? records.length : 0, 'results.');
        if (operation.wasSuccessful()) {
          stories = stories.concat(records);
        }
        iterations.shift();

        if (iterations.length > 0) {
          this.fetch_stories(iterations, stories);
        } else {
          if (stories.length > 0) {
            this.fetch_histories(stories);
          } else {
            this.haltEarly('No stories found.');
          }
        }
      }
    });
  },

  // Fetch the revisions for all the stories.
  fetch_histories: function(stories) {
    this._mask.msg = 'Fetching story histories...';
    this._mask.show();

    var hashed_stories = {};
    stories.forEach(function(s) {
      s.data.Revisions = [];
      hashed_stories[s.get('ObjectID')] = s;
    });

    var that = this;
    var t1 = new Date();
    var store = Ext.create('Rally.data.lookback.SnapshotStore', {
      fetch: ['ScheduleState', '_PreviousValues.ScheduleState', '_ValidFrom'],
      hydrate: ['ScheduleState', '_PreviousValues.ScheduleState'],
      filters: [
        {
          property: 'ObjectID',
          operator: 'in',
          value: stories.map(function(s) {
            return s.get('ObjectID');
          })
        }
      ],
      listeners: {
        load: function(store, data, success) {
          var t2 = new Date();
          console.log('Story histories query took', (t2 - t1), 'ms, and retrieved', data ? data.length : 0, 'results.');
          if (success) {
            data.filter(function(d) {
              return (
                (
                  d.get('_PreviousValues.ScheduleState')
                  && d.get('_PreviousValues.ScheduleState').length > 0
                )
                || d.get('_PreviousValues.ScheduleState') === null
              );
            }).forEach(function(d) {
              hashed_stories[d.get('ObjectID')].data.Revisions.push({
                from: d.get('_PreviousValues.ScheduleState'),
                to: d.get('ScheduleState'),
                on: d.get('_ValidFrom')
              });
            });
          }

          that.get_story_data(stories, []);
        }
      }
    });
    t1 = new Date();
    store.load({ scope: this });
  },

  // Given a millisecond count, format it as 'X days, Y hours'.
  format_ms: function(ms, method = null) {
    var hours = Math.round(ms / 1000 / 60 / 60);
    var days = Math.floor(hours / 24);
    hours -= (days * 24);

    if (method == 'ceil') {
      days += (hours > 0) ? 1 : 0;
    } else if (method == 'round') {
      days += (hours >= 12) ? 1 : 0;
    }

    var out = '';

    if (days > 0) {
      out += days;
      if (days == 1) {
        out += ' day';
      } else {
        out += ' days';
      }

      if (!method) {
        out += ', ';
      }
    }

    if (!method) {
      out += hours;
      if (hours == 1) {
        out += ' hour';
      } else {
        out += ' hours';
      }
    }

    return out;
  },

  // Recursively reformat the data for each story. Once they're all
  // reformatted, pass the data along to the table building function.
  get_story_data: function(raw_stories, stories) {
    this._mask.msg = 'Calculating story statistics...';
    this._mask.show();

    var raw_story = raw_stories[0];
    var story = {};
    this.data_keys.forEach(function(k) {
      story[k] = raw_story.get(k);
    });

    // Make the tags readable.
    story.Tags = story.Tags._tagsNameArray.map(function(o) {
      return o.Name;
    });

    // Make the type more readable and color the row based on the type.
    if (story._type == 'hierarchicalrequirement') {
      story._type = 'S';
      story.color = '#ffffff';
    } else if (story._type == 'defect') {
      if (story.Tags.indexOf('Customer Voice') == -1) {
        story._type = 'D';
        story.color = '#ffa500';
      } else {
        story._type = 'C';
        story.color = '#ff83fa';
      }
    }

    // Calculate the transition dates.
    var dates = [story.CreationDate, null, story.InProgressDate, null, story.AcceptedDate, null];
    var indices = ['This is junk data so that the CreationDate is not overwritten', 'Defined', 'In-Progress', 'Completed', 'Accepted', 'Released'];
    var back_count = 0;
    var back_flag = false;
    story.Revisions.forEach(function(r) {
      var i = indices.indexOf(r.to);
      if (i >= 0) {
        dates[i] = new Date(r.on);
        for (var j = i + 1; j < indices.length; j += 1) {
          if (!back_flag && dates[j]) {
            back_count += 1;
            back_flag = true;
          }
          dates[j] = null;
        }
        back_flag = false;
      }
    });

    // Fill in missing dates.
    var filled = [false, false, false, false, false, false];
    if (this.complete_dates) {
      // Complete the last three dates by copying
      // from the right.
      for (var i = 4; i >= 3; i -= 1) {
        if (!dates[i]) {
          dates[i] = dates[i + 1];
          filled[i] = true;
        }
      }

      // Complete the Defined date by copying the Created
      // date.
      if (!dates[1]) {
        dates[1] = dates[0];
        filled[1] = true;
      }

      // Complete the Started date if it can be
      // reasonably assumed.
      if (
        !dates[2] && dates[1] && dates[3]
        && dates[1].toDateString() == dates[3].toDateString()
      ) {
        dates[2] = dates[1];
        filled[2] = true;
      }
    }

    // Assign the transition dates to the story.
    var names = ['Created', 'Defined', 'Started', 'Completed', 'Accepted', 'Released'];
    for (var i = 0; i < 6; i += 1) {
      story[names[i] + 'Date'] = dates[i];
      story[names[i] + 'DateFilled'] = filled[i];
    }
    story.BackCount = back_count;

    // Check if this story skipped.
    var stage = 0;
    for (var i = 0; i < dates.length; i += 1) {
      if (stage == 0 && !dates[i]) {
        stage = 1;
      } else if (stage == 1 && dates[i]) {
        stage = 2;
      }
    }
    if (stage == 2) {
      story.Skipped = 'Y';
    }

    // Calculate cycle time.
    var cst = story[this.cycle_time_start_state + 'Date'];
    var cet = story[this.cycle_time_end_state + 'Date'];
    if (cst && cet) {
      story.CycleTimeMs = cet - cst;
      for (var d = new Date(cst); d <= cet; d.setDate(d.getDate() + 1)) {
        if (d.getDay() == 0 || d.getDay() == 6) {
          story.CycleTimeMs -= 24 * 60 * 60 * 1000;
        }
      }

      story.CycleTime = this.format_ms(story.CycleTimeMs, 'ceil');
    }

    // Process the next story.
    stories.push(story);
    raw_stories.shift();
    if (raw_stories.length > 0) {
      this.get_story_data(raw_stories, stories);
    } else {
      this.calculate_statistics(stories);
    }
  },

  // Calculate the overall statistics for the entire table.
  calculate_statistics: function(stories) {
    this._mask.msg = 'Calculating overall statistics...';
    this._mask.show();
    var that = this;
    total_stats = {
      C: { name: 'CV Defects', skipped: 0 },
      D: { name: 'Defects', skipped: 0 },
      S: { name: 'Stories', skipped: 0 }
    };

    // Filter out artifacts that lack a StartedDate.
    var filt_stories = stories.filter(function(s) {
      if (s.Skipped) {
        total_stats[s._type].skipped += 1;
        return false;
      } else {
        return true;
      }
    });

    // Throughput.
    Object.keys(total_stats).forEach(function(t) {
      total_stats[t].throughput_r = 0;
      total_stats[t].throughput_a = 0;
      filt_stories.forEach(function(s) {
        if (s._type == t) {
          if (s.ReleasedDate) {
            total_stats[t].throughput_r += 1;
            total_stats[t].throughput_a += 1;
          } else if (s.AcceptedDate) {
            total_stats[t].throughput_a += 1;
          }
        }
      });
    });

    // Weekly released.
    var weekdays = 0;
    var now = new Date();
    if (new Date(this.end_date) < now) {
      now = new Date(this.end_date);
    }
    for (var d = new Date(this.start_date); d <= now; d.setDate(d.getDate() + 1)) {
      if (d.getDay() != 0 && d.getDay() != 6) {
        weekdays += 1;
      }
    }
    Object.keys(total_stats).forEach(function(t) {
      total_stats[t].weekly_r = total_stats[t].throughput_r / (weekdays / 5.0);
    });

    // Average and median cycle time.
    Object.keys(total_stats).forEach(function(t) {
      total_stats[t].cycle_times = [];
      total_stats[t].cycle_count = 0;
    });
    var cst = this.cycle_time_start_state + 'Date';
    var cet = this.cycle_time_end_state + 'Date';
    filt_stories.forEach(function(s) {
      if (s[cst] && s[cet]) {
        var this_cycle_time = s[cet] - s[cst];
        for (var d = new Date(s[cst]); d <= s[cet]; d.setDate(d.getDate() + 1)) {
          if (d.getDay() == 0 || d.getDay() == 6) {
            this_cycle_time -= 1000 * 60 * 60 * 24;
          }
        }
        total_stats[s._type].cycle_times.push(this_cycle_time);
        total_stats[s._type].cycle_count += 1;
      }
    });
    Object.keys(total_stats).forEach(function(t) {
      if (total_stats[t].cycle_count > 0) {
        total_stats[t].cycle_times.sort(function(a, b) {
          return a - b;
        });
        var cts = total_stats[t].cycle_times;

        total_stats[t].cycle_time = 
          cts.reduce(function(a, b) {
            return a + b;
          }, 0) / 
          total_stats[t].cycle_count;

        if (cts.length % 2 == 0 ) {
          total_stats[t].median_ct = (cts[cts.length / 2 - 1] + cts[cts.length / 2]) / 2;
        } else {
          total_stats[t].median_ct = cts[Math.floor(cts.length / 2)];
        }
      }
    });

    this.removeAll();
    this.add_settings_link();
    this.build_stats_table(total_stats);
    this.build_table(stories);
    this.create_options(stories);
    this.build_plot(stories);
    this.build_flow_dia(stories);
    this._mask.hide();
  },

  // Return a label for a particular data point.
  label_datum: function(datum, type) {
    if (datum == 1) {
      if (type == 'S') {
        return '' + datum + ' story';
      } else {
        return '' + datum + ' defect';
      }
    } else {
      if (type == 'S') {
        return '' + datum + ' stories';
      } else {
        return '' + datum + ' defects';
      }
    }
  },

  create_options: function(stories) {
    var that = this;
    this.add({
      xtype: 'rallycombobox',
      itemId: 'bubble_select',
      fieldLabel: 'Color bubbles by:',
      store: ['Artifact type', 'Feature'],
      listeners: { change: {
        fn: that.change_bubble_type.bind(that)
      }}
    });

    this.stories = stories;
  },

  // Construct the HTML table to display the calculated
  // flow data.
  build_stats_table: function(total_stats) {
    var that = this;

    // The table-wide statistics.
    var stats = '<br /><div class="center title">Throughput Table</div>';
    stats += '<table class="center"><thead><tr>';
    Object.keys(that.columns_stats).forEach(function(k) {
      stats += '<th class="bold tablecell">';
      stats += k;
      stats += '</th>';
    });
    stats += '</tr></thead>';
    Object.keys(total_stats).forEach(function(t) {
      var ts = total_stats[t];
      stats += '<tr>';

      Object.keys(that.columns_stats).forEach(function(k) {
        var d = ts[that.columns_stats[k].key];
        stats += '<td class="tablecell center' +
          (that.columns_stats[k].highlight ?
            ' highlight"' :
            '"') +
          '>';
        if (that.columns_stats[k].label) {
          stats += that.label_datum(d.toLocaleString(), t);
        } else if (that.columns_stats[k].time) {
          stats += that.format_ms(d, 'ceil');
        } else {
          stats += d;
        }
        stats += '</td>';
      });

      stats += '</tr>';
    });
    stats += '</table>';

    this.add({
      xtype: 'component',
      html: stats
    });
  },

  // Construct the HTML table to display the story data.
  build_table: function(stories) {
    var that = this;

    // The toggle button.
    var button = '<br /><a id="toggle_link" href="javascript:;" onclick="toggle_big_table()">Show all stories</a><br />';

    // The table.
    var table = '<table style="display: none" id="big_table"><thead><tr><th class="tablecell">' +
      Object.keys(this.columns_big).join('</th><th class="tablecell">') +
      '</th></tr></thead>';
    stories.forEach(function(story) {
      table += that.build_table_row(story);
    });
    table += '</table><hr />';

    this.add({
      xtype: 'component',
      html: button + table
    });
  },

  // Given a story object, build an HTML row showing the relevant data.
  build_table_row: function(story) {
    var data = story;
    var row = '<tr>';
    var that = this;

    Object.keys(this.columns_big).forEach(function(col) {
      var datum = data[that.columns_big[col].key];
      var center = that.columns_big[col].center;
      var filled = false;
      if (!datum) {
        datum = '';
      } else if (that.columns_big[col].date) {
        filled = data[that.columns_big[col].key + 'Filled'];
        datum = datum.toDateString();
      }

      row += ('<td class="tablecell ' +
        (center ? 'center ' : '') +
        (filled ? 'filled ' : '') +
        '" ' +
        ('bgcolor="' + data.color + '" ') +
        '>' +
        datum +
        '</td>'
      );
    });

    return row;
  },

  // Make a scatter plot.
  build_plot: function(stories, mode = 'Artifact type') {
    var that = this;
    var by_artifact = (mode == 'Artifact type');

    var data, indices;
    if (by_artifact) {
      data = {
        series: [
          {
            name: 'Stories',
            data: []
          },
          {
            name: 'Defects',
            data: []
          },
          {
            name: 'CV Defects',
            data: []
          }
        ]
      };
      var indices = ['S', 'D', 'C'];
    } else {
      indices = ['No feature'];
      stories.forEach(function(s) {
        if (s.Feature && !indices.includes(s.Feature.Name)) {
          indices.push(s.Feature.Name);
        } else if (!s.Feature) {
          s.Feature = { Name: 'No feature' };
        }
      });
      data = { series: [] };
      indices.forEach(function(i) {
        data.series.push({
          name: i,
          data: []
        });
      });
    }
    stories.forEach(function(s) {
      var index = by_artifact ? s._type : s.Feature.Name;
      data.series[indices.indexOf(index)].data.push(s);
    });
    var omitted = 0;
    data.series.forEach(function(c) {
      c.data = c.data.map(function(s) {
        var cet = s[that.cycle_time_end_state + 'Date'];
        if (s.CycleTimeMs && cet) {
          var d = s.CycleTimeMs / 1000 / 60 / 60 / 24;
          var n = s.Name;
          if (n.length > 40) {
            n = n.substring(0, 37) + '...';
          }
          return { 
            x: cet, 
            y: d, 
            z: s.PlanEstimate || 0,
            name: n, 
            fid: s.FormattedID,
            year: cet.getFullYear(),
            month: that.months[cet.getMonth()],
            day: cet.getDate()
          };
        } else {
          return null;
        }
      }).filter(function(p) { 
        if (p && p.y >= that.cycle_time_threshold) {
          omitted += 1;
        }
        return p && p.y < that.cycle_time_threshold;
      });
    });

    this.bubble_chart = this.insert(4, {
      xtype: 'rallychart',
      loadMask: false,
      chartData: data,
      chartConfig: {
        chart: {
          type: 'bubble',
          zoomType: 'xy'
        },
        title: { text: 'Cycle Time This Quarter' },
        subtitle: { text: '<em>' + omitted + ' artifact' + (omitted == 1 ? '' : 's') + ' with cycle times longer than ' + this.cycle_time_threshold + ' days have been omitted.</em>' },
        xAxis: { 
          title: { text: this.cycle_time_end_state + ' date' },
          labels: { 
            formatter: function() {
              return new Date(this.value).toDateString();
            },
          }
        },
        yAxis: { 
          title: { text: 'Cycle time (days)' },
          min: 0
        },
        tooltip: {
          pointFormat: 
            '<b>{point.fid}</b>: {point.name}<br />' +
            this.cycle_time_end_state + ' on {point.day} {point.month} {point.year}<br />' +
            'Cycle time: {point.y:.2f} days<br />' +
            'Estimated at {point.z} points'
        },
        plotOptions: {
          bubble: {
            sizeBy: 'width'
          }
        }
      }
    });
  },

  // Build a cumulative flow diagram.
  build_flow_dia: function(stories) {
    var that = this;
    var labels = [
      // 'CreatedDate',
      // 'DefinedDate',
      'StartedDate',
      'CompletedDate',
      'AcceptedDate',
      'ReleasedDate'
    ];

    var totals = {};
    var start = {};
    var now = new Date();
    if (new Date(this.end_date) < now) {
      now = new Date(this.end_date);
    }
    for (var d = new Date(this.start_date); d <= now; d.setDate(d.getDate() + 1)) {
      totals[d.toDateString()] = {};
    }
    labels.forEach(function(dt) {
      Object.keys(totals).forEach(function(date) {
        totals[date][dt] = 0;
      });
      start[dt] = 0;
    });

    stories.forEach(function(s) {
      prev_state = null;

      labels.forEach(function(dt) {
        if (s[dt]) {
          if (totals.hasOwnProperty(s[dt].toDateString())) {
            totals[s[dt].toDateString()][dt] += 1;
            if (prev_state) {
              totals[s[dt].toDateString()][prev_state] -= 1;
            }
          } else if (s[dt] < new Date(that.start_date)) {
            start[dt] += 1;
            if (prev_state) {
              start[prev_state] -= 1;
            }
          }

          prev_state = dt;
        }
      });
    });

    var prev = start;
    var categories = [];
    var mapped_series = {};
    labels.forEach(function(dt) {
      mapped_series[dt] = [];
    });
    for (var d = new Date(this.start_date); d <= now; d.setDate(d.getDate() + 1)) {
      var df = d.toDateString();
      categories.push(df);
      labels.forEach(function(dt) {
        totals[df][dt] += prev[dt];
        mapped_series[dt].push(totals[df][dt]);
      });
      prev = totals[df];
    }

    var series = [];
    labels.forEach(function(dt) {
      series.push({
        name: dt.slice(0, -4),
        data: mapped_series[dt]
      });
    });

    var chart = this.add({
      xtype: 'rallychart',
      loadMask: false,
      chartData: { series: series, categories: categories },
      chartConfig: {
        chart: {
          type: 'area'
        },
        title: { text: 'Release Cumulative Flow' },
        xAxis: { 
          title: { enabled: false },
          tickInterval: 7
        },
        yAxis: { title: { text: 'Total points' } },
        plotOptions: {
          area: {
            stacking: 'normal',
            lineColor: '#666666',
            lineWidth: 1,
            tooltip: { split: true, valueSuffix: ' stories' },
            marker: { enabled: false }
          }
        }
      }
    });
  },

  change_bubble_type: function(t, new_item, old_item, e) {
    if (old_item && this.bubble_chart) {
      this.remove(this.bubble_chart);
      this.build_plot(this.stories, new_item);
    }
  },

  // Add a link that opens the app settings.
  add_settings_link: function() {
    this.add({
      xtype: 'component',
      html: '<a href="javascript:;" onClick="' +
            'Rally.getApp().showSettings()' +
            '">Modify app settings</a><br />'
    });
  }
});

Ext.define('ZzacksWeeklyThroughputDashboardApp', {
  extend: 'Rally.app.TimeboxScopedApp',
  scopeType: 'release',

  getUserSettingsFields: function() {
    return [];
  },

  onSettingsUpdate: function(settings) {
    console.log('Changed settings:', settings);
  },

  launch: function() {
    this._mask = new Ext.LoadMask(Ext.getBody(), {
      msg: 'Please wait...'
    });
    this._mask.show();

    this.project_oid = this.getContext().getProject().ObjectID;
    var start_date = this.calculate_first_date();
    this.fetch_stories({}, start_date, 52);
  },

  calculate_first_date: function() {
    var the_date = new Date();
    the_date.setDate(the_date.getDate() - 365);

    while (the_date.getDay() > 0) {
      the_date.setDate(the_date.getDate() - 1);
    }
    the_date.setHours(0, 0, 0, 0);

    return the_date;
  },

  fetch_stories: function(counts, start_date, count) {
    this._mask.msg = 'Fetching stories... (' + count + ' weeks left)';
    this._mask.show();

    var end_date = new Date(start_date);
    end_date.setDate(end_date.getDate() + 7);

    var that = this;
    var store = Ext.create('Rally.data.wsapi.artifact.Store', {
      models: ['UserStory', 'Defect'],
      filters: [
        {
          property: 'AcceptedDate',
          operator: '>=',
          value: start_date
        },
        {
          property: 'AcceptedDate',
          operator: '<',
          value: end_date
        }
      ]
    }, this);
    var t1 = new Date();
    store.load({
      scope: this,
      callback: function(records, operation) {
        var t2 = new Date();
        console.log('Stories query took', (t2 - t1), 'ms, and retrieved', records ? records.length : 0, 'results.');

        if (operation.wasSuccessful()) {
          var d = start_date.toDateString();
          counts[d] = {
            total_story_pts: 0,
            total_stories: 0,
            total_defect_pts: 0,
            total_defects: 0
          };
          records.forEach(function(r) {
            if (r.get('_type') == 'hierarchicalrequirement') {
              counts[d].total_story_pts += r.get('PlanEstimate');
              counts[d].total_stories += 1;
            } else if (r.get('_type') == 'defect') {
              counts[d].total_defect_pts += r.get('PlanEstimate');
              counts[d].total_defects += 1;
            }
          });
        }

        if (end_date < new Date()) {
          that.fetch_stories(counts, end_date, count - 1);
        } else {
          that.removeAll();
          that.create_options(counts);
        }
      }
    });
  },

  create_options: function(counts) {
    var that = this;
    this.add({
      xtype: 'rallycombobox',
      itemId: 'mode_select',
      fieldLabel: 'Combine stories & defects?',
      store: ['Separate', 'Combined'],
      listeners: { change: {
        fn: that.change_graph_mode.bind(that)
      }}
    });

    this.counts = counts;
    this.build_graph(counts, 'Separate');
  },

  build_graph(counts, mode) {
    this._mask.msg = 'Building graph...';
    this._mask.show();

    var combined = mode == 'Combined';

    var data = {
      series: [],
      categories: []
    };
    if (!combined) {
      data.series = [
        {
          name: 'Stories',
          data: []
        },
        {
          name: 'Defects',
          data: []
        }
      ];
    } else {
      data.series = [
        {
          name: 'Artifacts',
          data: []
        }
      ];
    }

    Object.keys(counts).forEach(function(d) {
      data.categories.push(d);
      if (!combined) {
        data.series[0].data.push({
          y: counts[d].total_stories,
          date: d,
          unit: 'stories'
        });
        data.series[1].data.push({
          y: counts[d].total_defects,
          date: d,
          unit: 'defects'
        });
      } else {
        data.series[0].data.push({
          y: counts[d].total_stories + counts[d].total_defects,
          date: d,
          unit: 'artifacts'
        });
      }
    });

    this.chart = this.add({
      xtype: 'rallychart',
      chartData: data,
      chartConfig: {
        chart: {
          type: 'line'
        },
        title: { text: 'Stories/defects accepted per week' },
        // subtitle: { text: 'subtitle' },
        xAxis: {
          title: { text: 'Week of...' },
          labels: {
            formatter: function() {
              return new Date(this.value).toDateString();
            },
            step: 2,
            rotation: -65
          }
        },
        yAxis: {
          title: { text: 'Artifacts accepted' },
          min: 0
        },
        tooltip: {
          pointFormat:
            '{point.date}<br />' +
            '<b>{point.y} {point.unit}</b>',
          headerFormat: ''
        }
      }
    });

    this._mask.hide();
  },

  change_graph_mode: function(t, new_item, old_item, e) {
    if (old_item && this.chart) {
      this.remove(this.chart);
      this.build_graph(this.counts, new_item);
    }
  }
});

      });
    </script>

    <style type="text/css">
      table {
        border-collapse: collapse;
      }

      .tablecell {
        border: 1px solid black;
        padding-left: 10px;
        padding-right: 10px;
      }

      .title {
        font-weight: bold;
        font-size: 14pt;
      }

      .bold {
        font-weight: bold;
        background-color: #e0e0e0;
      }

      .highlight {
        font-size: 10pt;
      }

      .center {
        text-align: center;
        margin-left: auto;
        margin-right: auto;
      }

      .filled {
        font-style: italic;
        color: #808080;
      }
    </style>
  </head>
  <body>
    <div>
      <ul>
        <li><a 
          href="javascript:void(0)" 
          onclick="Rally.launchApp('ZzacksTeamDashboardApp')"
        >Team Dashboard</a></li>
        <li><a 
          href="javascript:void(0)" 
          onclick="Rally.launchApp('ZzacksFeatureDashboardApp')"
        >Feature Dashboard</a></li>
        <li><a 
          href="javascript:void(0)" 
          onclick="Rally.launchApp('ZzacksInitiativeDashboardApp')"
        >Initiative Dashboard</a></li>
        <li><a 
          href="javascript:void(0)" 
          onclick="Rally.launchApp('ZzacksAllWorkDashboardApp')"
        >All Work Dashboard</a></li>
        <li><a 
          href="javascript:void(0)" 
          onclick="Rally.launchApp('ZzacksWeeklyThroughputDashboardApp')"
        >Weekly Throughput Dashboard</a></li>
      </ul>
    </div>
  </body>
</html>
